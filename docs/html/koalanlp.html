

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="ko" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="ko" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>KoalaNLP Python3 API &mdash; KoalaNLP 2.0.9 문서</title>
  

  
  
  
  

  
  <script type="text/javascript" src="_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
        <script type="text/javascript" src="_static/jquery.js"></script>
        <script type="text/javascript" src="_static/underscore.js"></script>
        <script type="text/javascript" src="_static/doctools.js"></script>
        <script type="text/javascript" src="_static/language_data.js"></script>
        <script type="text/javascript" src="_static/translations.js"></script>
    
    <script type="text/javascript" src="_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <link rel="index" title="색인" href="genindex.html" />
    <link rel="search" title="검색" href="search.html" />
    <link rel="prev" title="KoalaNLP" href="index.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="index.html" class="icon icon-home"> KoalaNLP
          

          
          </a>

          
            
            
              <div class="version">
                2.0
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul class="current">
<li class="toctree-l1"><a class="reference external" href="https://koalanlp.github.io/koalanlp/usage/">주요 기능 사용법</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">KoalaNLP Python3 API</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#module-koalanlp.API">API 목록</a></li>
<li class="toctree-l2"><a class="reference internal" href="#module-koalanlp.types">품사, 기능 표지자 등</a></li>
<li class="toctree-l2"><a class="reference internal" href="#module-koalanlp.data">자료형</a></li>
<li class="toctree-l2"><a class="reference internal" href="#module-koalanlp.proc">사전 및 분석기</a></li>
<li class="toctree-l2"><a class="reference internal" href="#module-koalanlp.ExtUtil">문자열 추가기능</a></li>
<li class="toctree-l2"><a class="reference internal" href="#module-koalanlp.Util">편의기능</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference external" href="https://koalanlp.github.io/sample/">사용법 샘플</a></li>
<li class="toctree-l1"><a class="reference external" href="https://koalanlp.github.io/koalanlp/api/koalanlp/index.html">Kotlin/Java API</a></li>
<li class="toctree-l1"><a class="reference external" href="https://koalanlp.github.io/scala-support">Scala API</a></li>
<li class="toctree-l1"><a class="reference external" href="https://koalanlp.github.io/nodejs-support">NodeJS API</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">KoalaNLP</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="index.html">Docs</a> &raquo;</li>
        
      <li>KoalaNLP Python3 API</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="_sources/koalanlp.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="koalanlp-python3-api">
<h1>KoalaNLP Python3 API<a class="headerlink" href="#koalanlp-python3-api" title="제목 주소">¶</a></h1>
<div class="section" id="module-koalanlp.API">
<span id="api"></span><h2>API 목록<a class="headerlink" href="#module-koalanlp.API" title="제목 주소">¶</a></h2>
<dl class="data">
<dt id="koalanlp.API.HNN">
<code class="sig-prename descclassname">koalanlp.API.</code><code class="sig-name descname">HNN</code><em class="property"> = 'hnn'</em><a class="headerlink" href="#koalanlp.API.HNN" title="정의 주소">¶</a></dt>
<dd><p>한나눔. 현재 <img alt="API.hnn Version" src="https://img.shields.io/maven-central/v/kr.bydelta/koalanlp-hnn.svg?style=flat-square&amp;label=API" /> 버전이 최신입니다. 문장분리, 품사분석, 구문분석, 의존분석이 가능합니다.</p>
</dd></dl>

<dl class="data">
<dt id="koalanlp.API.KMR">
<code class="sig-prename descclassname">koalanlp.API.</code><code class="sig-name descname">KMR</code><em class="property"> = 'kmr'</em><a class="headerlink" href="#koalanlp.API.KMR" title="정의 주소">¶</a></dt>
<dd><p>코모란. 현재 <img alt="API.kmr Version" src="https://img.shields.io/maven-central/v/kr.bydelta/koalanlp-kmr.svg?style=flat-square&amp;label=API" /> 버전이 최신입니다. 품사분석만 가능합니다.</p>
</dd></dl>

<dl class="data">
<dt id="koalanlp.API.KKMA">
<code class="sig-prename descclassname">koalanlp.API.</code><code class="sig-name descname">KKMA</code><em class="property"> = 'kkma'</em><a class="headerlink" href="#koalanlp.API.KKMA" title="정의 주소">¶</a></dt>
<dd><p>꼬꼬마. 현재 <img alt="API.kkma Version" src="https://img.shields.io/maven-central/v/kr.bydelta/koalanlp-kkma.svg?style=flat-square&amp;label=API" /> 버전이 최신입니다. 품사분석, 의존분석만 가능합니다.</p>
</dd></dl>

<dl class="data">
<dt id="koalanlp.API.EUNJEON">
<code class="sig-prename descclassname">koalanlp.API.</code><code class="sig-name descname">EUNJEON</code><em class="property"> = 'eunjeon'</em><a class="headerlink" href="#koalanlp.API.EUNJEON" title="정의 주소">¶</a></dt>
<dd><p>은전한닢. 현재 <img alt="API.eunjeon Version" src="https://img.shields.io/maven-central/v/kr.bydelta/koalanlp-eunjeon.svg?style=flat-square&amp;label=API" /> 버전이 최신입니다. 품사분석만 가능합니다.</p>
</dd></dl>

<dl class="data">
<dt id="koalanlp.API.ARIRANG">
<code class="sig-prename descclassname">koalanlp.API.</code><code class="sig-name descname">ARIRANG</code><em class="property"> = 'arirang'</em><a class="headerlink" href="#koalanlp.API.ARIRANG" title="정의 주소">¶</a></dt>
<dd><p>아리랑. 현재 <img alt="API.arirang Version" src="https://img.shields.io/maven-central/v/kr.bydelta/koalanlp-arirang.svg?style=flat-square&amp;label=API" /> 버전이 최신입니다. 품사분석만 가능합니다.</p>
</dd></dl>

<dl class="data">
<dt id="koalanlp.API.RHINO">
<code class="sig-prename descclassname">koalanlp.API.</code><code class="sig-name descname">RHINO</code><em class="property"> = 'rhino'</em><a class="headerlink" href="#koalanlp.API.RHINO" title="정의 주소">¶</a></dt>
<dd><p>라이노. 현재 <img alt="API.rhino Version" src="https://img.shields.io/maven-central/v/kr.bydelta/koalanlp-rhino.svg?style=flat-square&amp;label=API" /> 버전이 최신입니다. 품사분석만 가능합니다.</p>
</dd></dl>

<dl class="data">
<dt id="koalanlp.API.OKT">
<code class="sig-prename descclassname">koalanlp.API.</code><code class="sig-name descname">OKT</code><em class="property"> = 'okt'</em><a class="headerlink" href="#koalanlp.API.OKT" title="정의 주소">¶</a></dt>
<dd><p>트위터. 현재 <img alt="API.okt Version" src="https://img.shields.io/maven-central/v/kr.bydelta/koalanlp-okt.svg?style=flat-square&amp;label=API" /> 버전이 최신입니다. 문장분리, 품사분석만 가능합니다.</p>
</dd></dl>

<dl class="data">
<dt id="koalanlp.API.DAON">
<code class="sig-prename descclassname">koalanlp.API.</code><code class="sig-name descname">DAON</code><em class="property"> = 'daon'</em><a class="headerlink" href="#koalanlp.API.DAON" title="정의 주소">¶</a></dt>
<dd><p>다온. 현재 <img alt="API.daon Version" src="https://img.shields.io/maven-central/v/kr.bydelta/koalanlp-daon.svg?style=flat-square&amp;label=API" /> 버전이 최신입니다. 품사분석만 가능합니다.</p>
</dd></dl>

<dl class="data">
<dt id="koalanlp.API.ETRI">
<code class="sig-prename descclassname">koalanlp.API.</code><code class="sig-name descname">ETRI</code><em class="property"> = 'etri'</em><a class="headerlink" href="#koalanlp.API.ETRI" title="정의 주소">¶</a></dt>
<dd><p>ETRI Open API. 현재 <img alt="API.etri Version" src="https://img.shields.io/maven-central/v/kr.bydelta/koalanlp-etri.svg?style=flat-square&amp;label=API" /> 버전이 최신입니다.</p>
</dd></dl>

<dl class="data">
<dt id="koalanlp.API.CORE">
<code class="sig-prename descclassname">koalanlp.API.</code><code class="sig-name descname">CORE</code><em class="property"> = 'core'</em><a class="headerlink" href="#koalanlp.API.CORE" title="정의 주소">¶</a></dt>
<dd><p>분석기 Interface 정의 라이브러리. 현재 <img alt="API.core Version" src="https://img.shields.io/maven-central/v/kr.bydelta/koalanlp-core.svg?style=flat-square&amp;label=API" /> 버전이 최신입니다. 편의기능을 제공하며 타 분석기 참조시 함께 참조됩니다.</p>
</dd></dl>

</div>
<div class="section" id="module-koalanlp.types">
<span id="id1"></span><h2>품사, 기능 표지자 등<a class="headerlink" href="#module-koalanlp.types" title="제목 주소">¶</a></h2>
<dl class="class">
<dt id="koalanlp.types.POS">
<em class="property">class </em><code class="sig-prename descclassname">koalanlp.types.</code><code class="sig-name descname">POS</code><span class="sig-paren">(</span><em class="sig-param">reference</em><span class="sig-paren">)</span><a class="headerlink" href="#koalanlp.types.POS" title="정의 주소">¶</a></dt>
<dd><p>기반 클래스: <code class="xref py py-class docutils literal notranslate"><span class="pre">koalanlp.types._JavaEnum</span></code></p>
<p>세종 품사표기</p>
<dl class="method">
<dt id="koalanlp.types.POS.isAffix">
<code class="sig-name descname">isAffix</code><span class="sig-paren">(</span><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#koalanlp.types.POS.isAffix" title="정의 주소">¶</a></dt>
<dd><p>이 값이 접사인지 확인합니다.</p>
<dl class="field-list simple">
<dt class="field-odd">반환 형식</dt>
<dd class="field-odd"><p>bool</p>
</dd>
<dt class="field-even">반환값</dt>
<dd class="field-even"><p>접사인 경우 True</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="koalanlp.types.POS.isEnding">
<code class="sig-name descname">isEnding</code><span class="sig-paren">(</span><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#koalanlp.types.POS.isEnding" title="정의 주소">¶</a></dt>
<dd><p>이 값이 어미인지 확인합니다.</p>
<dl class="field-list simple">
<dt class="field-odd">반환 형식</dt>
<dd class="field-odd"><p>bool</p>
</dd>
<dt class="field-even">반환값</dt>
<dd class="field-even"><p>어미인 경우 True</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="koalanlp.types.POS.isModifier">
<code class="sig-name descname">isModifier</code><span class="sig-paren">(</span><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#koalanlp.types.POS.isModifier" title="정의 주소">¶</a></dt>
<dd><p>이 값이 수식언인지 확인합니다.</p>
<dl class="field-list simple">
<dt class="field-odd">반환 형식</dt>
<dd class="field-odd"><p>bool</p>
</dd>
<dt class="field-even">반환값</dt>
<dd class="field-even"><p>수식언인 경우 True</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="koalanlp.types.POS.isNoun">
<code class="sig-name descname">isNoun</code><span class="sig-paren">(</span><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#koalanlp.types.POS.isNoun" title="정의 주소">¶</a></dt>
<dd><p>이 값이 체언인지 확인합니다.</p>
<dl class="field-list simple">
<dt class="field-odd">반환 형식</dt>
<dd class="field-odd"><p>bool</p>
</dd>
<dt class="field-even">반환값</dt>
<dd class="field-even"><p>체언인 경우 True</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="koalanlp.types.POS.isPostPosition">
<code class="sig-name descname">isPostPosition</code><span class="sig-paren">(</span><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#koalanlp.types.POS.isPostPosition" title="정의 주소">¶</a></dt>
<dd><p>이 값이 관계언(조사)인지 확인합니다.</p>
<dl class="field-list simple">
<dt class="field-odd">반환 형식</dt>
<dd class="field-odd"><p>bool</p>
</dd>
<dt class="field-even">반환값</dt>
<dd class="field-even"><p>관계언인 경우 True</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="koalanlp.types.POS.isPredicate">
<code class="sig-name descname">isPredicate</code><span class="sig-paren">(</span><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#koalanlp.types.POS.isPredicate" title="정의 주소">¶</a></dt>
<dd><p>이 값이 용언인지 확인합니다.</p>
<dl class="field-list simple">
<dt class="field-odd">반환 형식</dt>
<dd class="field-odd"><p>bool</p>
</dd>
<dt class="field-even">반환값</dt>
<dd class="field-even"><p>용언인 경우 True</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="koalanlp.types.POS.isSuffix">
<code class="sig-name descname">isSuffix</code><span class="sig-paren">(</span><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#koalanlp.types.POS.isSuffix" title="정의 주소">¶</a></dt>
<dd><p>이 값이 접미사인지 확인합니다.</p>
<dl class="field-list simple">
<dt class="field-odd">반환 형식</dt>
<dd class="field-odd"><p>bool</p>
</dd>
<dt class="field-even">반환값</dt>
<dd class="field-even"><p>접미사인 경우 True</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="koalanlp.types.POS.isSymbol">
<code class="sig-name descname">isSymbol</code><span class="sig-paren">(</span><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#koalanlp.types.POS.isSymbol" title="정의 주소">¶</a></dt>
<dd><p>이 값이 기호인지 확인합니다.</p>
<dl class="field-list simple">
<dt class="field-odd">반환 형식</dt>
<dd class="field-odd"><p>bool</p>
</dd>
<dt class="field-even">반환값</dt>
<dd class="field-even"><p>기호인 경우 True</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="koalanlp.types.POS.isUnknown">
<code class="sig-name descname">isUnknown</code><span class="sig-paren">(</span><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#koalanlp.types.POS.isUnknown" title="정의 주소">¶</a></dt>
<dd><p>이 값이 미확인 단어인지 확인합니다.</p>
<dl class="field-list simple">
<dt class="field-odd">반환 형식</dt>
<dd class="field-odd"><p>bool</p>
</dd>
<dt class="field-even">반환값</dt>
<dd class="field-even"><p>미확인 단어인 경우 True</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="koalanlp.types.POS.startsWith">
<code class="sig-name descname">startsWith</code><span class="sig-paren">(</span><em class="sig-param">tag: str</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#koalanlp.types.POS.startsWith" title="정의 주소">¶</a></dt>
<dd><p>이 값이 주어진 [tag]로 시작하는지 확인합니다.</p>
<dl class="field-list simple">
<dt class="field-odd">매개변수</dt>
<dd class="field-odd"><p><strong>tag</strong> (<em>str</em>) -- 시작하는지 확인할 품사 분류</p>
</dd>
<dt class="field-even">반환값</dt>
<dd class="field-even"><p>포함되는 경우(시작하는 경우) True</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="koalanlp.types.POS.valueOf">
<em class="property">static </em><code class="sig-name descname">valueOf</code><span class="sig-paren">(</span><em class="sig-param">name: str</em><span class="sig-paren">)</span><a class="headerlink" href="#koalanlp.types.POS.valueOf" title="정의 주소">¶</a></dt>
<dd><p>해당하는 name과 일치하는 POS 값을 돌려줍니다.</p>
<dl class="field-list simple">
<dt class="field-odd">매개변수</dt>
<dd class="field-odd"><p><strong>name</strong> (<em>str</em>) -- POS 값을 찾을 명칭.</p>
</dd>
<dt class="field-even">반환 형식</dt>
<dd class="field-even"><p><a class="reference internal" href="#koalanlp.types.POS" title="koalanlp.types.POS">POS</a></p>
</dd>
<dt class="field-odd">반환값</dt>
<dd class="field-odd"><p>일치하는 POS값</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="koalanlp.types.POS.values">
<em class="property">static </em><code class="sig-name descname">values</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#koalanlp.types.POS.values" title="정의 주소">¶</a></dt>
<dd><p>POS 값들을 모두 돌려줍니다.</p>
<dl class="field-list simple">
<dt class="field-odd">반환 형식</dt>
<dd class="field-odd"><p>Set[<a class="reference internal" href="#koalanlp.types.POS" title="koalanlp.types.POS">POS</a>]</p>
</dd>
<dt class="field-even">반환값</dt>
<dd class="field-even"><p>모든 품사 태그의 Set</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="koalanlp.types.CoarseEntityType">
<em class="property">class </em><code class="sig-prename descclassname">koalanlp.types.</code><code class="sig-name descname">CoarseEntityType</code><span class="sig-paren">(</span><em class="sig-param">reference</em><span class="sig-paren">)</span><a class="headerlink" href="#koalanlp.types.CoarseEntityType" title="정의 주소">¶</a></dt>
<dd><p>기반 클래스: <code class="xref py py-class docutils literal notranslate"><span class="pre">koalanlp.types._JavaEnum</span></code></p>
<p>ETRI 개체명 대분류</p>
<dl class="method">
<dt id="koalanlp.types.CoarseEntityType.valueOf">
<em class="property">static </em><code class="sig-name descname">valueOf</code><span class="sig-paren">(</span><em class="sig-param">name: str</em><span class="sig-paren">)</span><a class="headerlink" href="#koalanlp.types.CoarseEntityType.valueOf" title="정의 주소">¶</a></dt>
<dd><p>해당하는 name과 일치하는 CoarseEntityType 값을 돌려줍니다.</p>
<dl class="field-list simple">
<dt class="field-odd">매개변수</dt>
<dd class="field-odd"><p><strong>name</strong> (<em>str</em>) -- 값을 찾을 명칭.</p>
</dd>
<dt class="field-even">반환 형식</dt>
<dd class="field-even"><p><a class="reference internal" href="#koalanlp.types.CoarseEntityType" title="koalanlp.types.CoarseEntityType">CoarseEntityType</a></p>
</dd>
<dt class="field-odd">반환값</dt>
<dd class="field-odd"><p>일치하는 CoarseEntityType값</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="koalanlp.types.CoarseEntityType.values">
<em class="property">static </em><code class="sig-name descname">values</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#koalanlp.types.CoarseEntityType.values" title="정의 주소">¶</a></dt>
<dd><p>CoarseEntityType 값들을 모두 돌려줍니다.</p>
<dl class="field-list simple">
<dt class="field-odd">반환 형식</dt>
<dd class="field-odd"><p>Set[<a class="reference internal" href="#koalanlp.types.CoarseEntityType" title="koalanlp.types.CoarseEntityType">CoarseEntityType</a>]</p>
</dd>
<dt class="field-even">반환값</dt>
<dd class="field-even"><p>모든 개체명 태그의 Set</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="koalanlp.types.PhraseTag">
<em class="property">class </em><code class="sig-prename descclassname">koalanlp.types.</code><code class="sig-name descname">PhraseTag</code><span class="sig-paren">(</span><em class="sig-param">reference</em><span class="sig-paren">)</span><a class="headerlink" href="#koalanlp.types.PhraseTag" title="정의 주소">¶</a></dt>
<dd><p>기반 클래스: <code class="xref py py-class docutils literal notranslate"><span class="pre">koalanlp.types._JavaEnum</span></code></p>
<p>세종 구문구조 표지자</p>
<dl class="method">
<dt id="koalanlp.types.PhraseTag.valueOf">
<em class="property">static </em><code class="sig-name descname">valueOf</code><span class="sig-paren">(</span><em class="sig-param">name: str</em><span class="sig-paren">)</span><a class="headerlink" href="#koalanlp.types.PhraseTag.valueOf" title="정의 주소">¶</a></dt>
<dd><p>해당하는 name과 일치하는 PhraseTag 값을 돌려줍니다.</p>
<dl class="field-list simple">
<dt class="field-odd">매개변수</dt>
<dd class="field-odd"><p><strong>name</strong> (<em>str</em>) -- 값을 찾을 명칭.</p>
</dd>
<dt class="field-even">반환 형식</dt>
<dd class="field-even"><p><a class="reference internal" href="#koalanlp.types.PhraseTag" title="koalanlp.types.PhraseTag">PhraseTag</a></p>
</dd>
<dt class="field-odd">반환값</dt>
<dd class="field-odd"><p>일치하는 PhraseTag값</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="koalanlp.types.PhraseTag.values">
<em class="property">static </em><code class="sig-name descname">values</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#koalanlp.types.PhraseTag.values" title="정의 주소">¶</a></dt>
<dd><p>PhraseTag 값들을 모두 돌려줍니다.</p>
<dl class="field-list simple">
<dt class="field-odd">반환 형식</dt>
<dd class="field-odd"><p>Set[<a class="reference internal" href="#koalanlp.types.PhraseTag" title="koalanlp.types.PhraseTag">PhraseTag</a>]</p>
</dd>
<dt class="field-even">반환값</dt>
<dd class="field-even"><p>모든 구문구조 태그의 Set</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="koalanlp.types.DependencyTag">
<em class="property">class </em><code class="sig-prename descclassname">koalanlp.types.</code><code class="sig-name descname">DependencyTag</code><span class="sig-paren">(</span><em class="sig-param">reference</em><span class="sig-paren">)</span><a class="headerlink" href="#koalanlp.types.DependencyTag" title="정의 주소">¶</a></dt>
<dd><p>기반 클래스: <code class="xref py py-class docutils literal notranslate"><span class="pre">koalanlp.types._JavaEnum</span></code></p>
<p>ETRI 의존구문구조 기능표지자</p>
<dl class="method">
<dt id="koalanlp.types.DependencyTag.valueOf">
<em class="property">static </em><code class="sig-name descname">valueOf</code><span class="sig-paren">(</span><em class="sig-param">name: str</em><span class="sig-paren">)</span><a class="headerlink" href="#koalanlp.types.DependencyTag.valueOf" title="정의 주소">¶</a></dt>
<dd><p>해당하는 name과 일치하는 DependencyTag 값을 돌려줍니다.</p>
<dl class="field-list simple">
<dt class="field-odd">매개변수</dt>
<dd class="field-odd"><p><strong>name</strong> (<em>str</em>) -- 값을 찾을 명칭.</p>
</dd>
<dt class="field-even">반환 형식</dt>
<dd class="field-even"><p><a class="reference internal" href="#koalanlp.types.DependencyTag" title="koalanlp.types.DependencyTag">DependencyTag</a></p>
</dd>
<dt class="field-odd">반환값</dt>
<dd class="field-odd"><p>일치하는 DependencyTag값</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="koalanlp.types.DependencyTag.values">
<em class="property">static </em><code class="sig-name descname">values</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#koalanlp.types.DependencyTag.values" title="정의 주소">¶</a></dt>
<dd><p>DependencyTag 값들을 모두 돌려줍니다.</p>
<dl class="field-list simple">
<dt class="field-odd">반환 형식</dt>
<dd class="field-odd"><p>Set[<a class="reference internal" href="#koalanlp.types.DependencyTag" title="koalanlp.types.DependencyTag">DependencyTag</a>]</p>
</dd>
<dt class="field-even">반환값</dt>
<dd class="field-even"><p>모든 의존구조 기능 태그의 Set</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="koalanlp.types.RoleType">
<em class="property">class </em><code class="sig-prename descclassname">koalanlp.types.</code><code class="sig-name descname">RoleType</code><span class="sig-paren">(</span><em class="sig-param">reference</em><span class="sig-paren">)</span><a class="headerlink" href="#koalanlp.types.RoleType" title="정의 주소">¶</a></dt>
<dd><p>기반 클래스: <code class="xref py py-class docutils literal notranslate"><span class="pre">koalanlp.types._JavaEnum</span></code></p>
<p>ETRI 의미역 분석 표지</p>
<dl class="method">
<dt id="koalanlp.types.RoleType.valueOf">
<em class="property">static </em><code class="sig-name descname">valueOf</code><span class="sig-paren">(</span><em class="sig-param">name: str</em><span class="sig-paren">)</span><a class="headerlink" href="#koalanlp.types.RoleType.valueOf" title="정의 주소">¶</a></dt>
<dd><p>해당하는 name과 일치하는 RoleType 값을 돌려줍니다.</p>
<dl class="field-list simple">
<dt class="field-odd">매개변수</dt>
<dd class="field-odd"><p><strong>name</strong> (<em>str</em>) -- 값을 찾을 명칭.</p>
</dd>
<dt class="field-even">반환 형식</dt>
<dd class="field-even"><p><a class="reference internal" href="#koalanlp.types.RoleType" title="koalanlp.types.RoleType">RoleType</a></p>
</dd>
<dt class="field-odd">반환값</dt>
<dd class="field-odd"><p>일치하는 RoleType값</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="koalanlp.types.RoleType.values">
<em class="property">static </em><code class="sig-name descname">values</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#koalanlp.types.RoleType.values" title="정의 주소">¶</a></dt>
<dd><p>RoleType 값들을 모두 돌려줍니다.</p>
<dl class="field-list simple">
<dt class="field-odd">반환 형식</dt>
<dd class="field-odd"><p>Set[<a class="reference internal" href="#koalanlp.types.RoleType" title="koalanlp.types.RoleType">RoleType</a>]</p>
</dd>
<dt class="field-even">반환값</dt>
<dd class="field-even"><p>모든 의미역 태그의 Set</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-koalanlp.data">
<span id="id2"></span><h2>자료형<a class="headerlink" href="#module-koalanlp.data" title="제목 주소">¶</a></h2>
<dl class="class">
<dt id="koalanlp.data.Entity">
<em class="property">class </em><code class="sig-prename descclassname">koalanlp.data.</code><code class="sig-name descname">Entity</code><span class="sig-paren">(</span><em class="sig-param">surface: str, label: Union[str, koalanlp.types.CoarseEntityType], fineLabel: str, morphemes: List, originalLabel: str = None</em><span class="sig-paren">)</span><a class="headerlink" href="#koalanlp.data.Entity" title="정의 주소">¶</a></dt>
<dd><p>개체명 분석 결과를 저장할 [Property] class</p>
<dl>
<dt>참고:</dt><dd><p><strong>개체명 인식</strong> 은 문장에서 인물, 장소, 기관, 대상 등을 인식하는 기술입니다.</p>
<p>예) '철저한 진상 조사를 촉구하는 국제사회의 목소리가 커지고 있는 가운데, 트럼프 미국 대통령은 되레 사우디를 감싸고 나섰습니다.'에서, 다음을 인식하는 기술입니다.</p>
<ul class="simple">
<li><p>'트럼프': 인물</p></li>
<li><p>'미국' : 국가</p></li>
<li><p>'대통령' : 직위</p></li>
<li><p>'사우디' : 국가</p></li>
</ul>
<p>아래를 참고해보세요.</p>
<ul class="simple">
<li><p><a class="reference internal" href="#koalanlp.proc.EntityRecognizer" title="koalanlp.proc.EntityRecognizer"><code class="xref py py-class docutils literal notranslate"><span class="pre">koalanlp.proc.EntityRecognizer</span></code></a> 개체명 인식기 interface</p></li>
<li><p><a class="reference internal" href="#koalanlp.data.Morpheme.getEntities" title="koalanlp.data.Morpheme.getEntities"><code class="xref py py-meth docutils literal notranslate"><span class="pre">koalanlp.data.Morpheme.getEntities()</span></code></a> 형태소가 속하는 [Entity]를 가져오는 API</p></li>
<li><p><a class="reference internal" href="#koalanlp.data.Word.getEntities" title="koalanlp.data.Word.getEntities"><code class="xref py py-meth docutils literal notranslate"><span class="pre">koalanlp.data.Word.getEntities()</span></code></a> 어절에 연관된 모든 [Entity]를 가져오는 API</p></li>
<li><p><a class="reference internal" href="#koalanlp.data.Sentence.getEntities" title="koalanlp.data.Sentence.getEntities"><code class="xref py py-meth docutils literal notranslate"><span class="pre">koalanlp.data.Sentence.getEntities()</span></code></a> 문장에 포함된 모든 [Entity]를 가져오는 API</p></li>
<li><p><a class="reference internal" href="#koalanlp.types.CoarseEntityType" title="koalanlp.types.CoarseEntityType"><code class="xref py py-class docutils literal notranslate"><span class="pre">koalanlp.types.CoarseEntityType</span></code></a> [Entity]의 대분류 개체명 분류구조 Enum 값</p></li>
</ul>
</dd>
</dl>
<dl class="method">
<dt id="koalanlp.data.Entity.__contains__">
<code class="sig-name descname">__contains__</code><span class="sig-paren">(</span><em class="sig-param">item</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#koalanlp.data.Entity.__contains__" title="정의 주소">¶</a></dt>
<dd><p>대상이 포함되는지 확인합니다.</p>
<dl class="field-list simple">
<dt class="field-odd">매개변수</dt>
<dd class="field-odd"><p><strong>item</strong> -- 포함되는지 확인할 대상</p>
</dd>
<dt class="field-even">반환 형식</dt>
<dd class="field-even"><p>bool</p>
</dd>
<dt class="field-odd">반환값</dt>
<dd class="field-odd"><p>해당 대상이 포함되면 true.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="koalanlp.data.Entity.__eq__">
<code class="sig-name descname">__eq__</code><span class="sig-paren">(</span><em class="sig-param">other</em><span class="sig-paren">)</span><a class="headerlink" href="#koalanlp.data.Entity.__eq__" title="정의 주소">¶</a></dt>
<dd><p>두 대상이 같은지 확인합니다.</p>
<dl class="field-list simple">
<dt class="field-odd">매개변수</dt>
<dd class="field-odd"><p><strong>other</strong> -- 이 객체와 비교할 다른 객체</p>
</dd>
<dt class="field-even">반환 형식</dt>
<dd class="field-even"><p>bool</p>
</dd>
<dt class="field-odd">반환값</dt>
<dd class="field-odd"><p>Java Reference가 같다면 true.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="koalanlp.data.Entity.__getitem__">
<code class="sig-name descname">__getitem__</code><span class="sig-paren">(</span><em class="sig-param">item</em><span class="sig-paren">)</span><a class="headerlink" href="#koalanlp.data.Entity.__getitem__" title="정의 주소">¶</a></dt>
<dd><p>포함된 대상을 가져옵니다.</p>
<dl class="field-list simple">
<dt class="field-odd">매개변수</dt>
<dd class="field-odd"><p><strong>item</strong> -- index의 번호 또는 slice</p>
</dd>
<dt class="field-even">반환값</dt>
<dd class="field-even"><p>지정된 위치에 있는 대상(들)</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="koalanlp.data.Entity.__hash__">
<code class="sig-name descname">__hash__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#koalanlp.data.Entity.__hash__" title="정의 주소">¶</a></dt>
<dd><p>해쉬 값을 계산합니다.</p>
<dl class="field-list simple">
<dt class="field-odd">반환 형식</dt>
<dd class="field-odd"><p>int</p>
</dd>
<dt class="field-even">반환값</dt>
<dd class="field-even"><p>Java Reference의 Hash code</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="koalanlp.data.Entity.__iter__">
<code class="sig-name descname">__iter__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#koalanlp.data.Entity.__iter__" title="정의 주소">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">반환 형식</dt>
<dd class="field-odd"><p>iter</p>
</dd>
<dt class="field-even">반환값</dt>
<dd class="field-even"><p>포함된 대상을 순회하는 iterator</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="koalanlp.data.Entity.__len__">
<code class="sig-name descname">__len__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#koalanlp.data.Entity.__len__" title="정의 주소">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">반환 형식</dt>
<dd class="field-odd"><p>int</p>
</dd>
<dt class="field-even">반환값</dt>
<dd class="field-even"><p>포함된 대상의 개수</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="koalanlp.data.Entity.__repr__">
<code class="sig-name descname">__repr__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#koalanlp.data.Entity.__repr__" title="정의 주소">¶</a></dt>
<dd><p>Return repr(self).</p>
</dd></dl>

<dl class="method">
<dt id="koalanlp.data.Entity.copy">
<code class="sig-name descname">copy</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#koalanlp.data.Entity.copy" title="정의 주소">¶</a></dt>
<dd><dl class="simple">
<dt>참고:</dt><dd><p><code class="xref py py-meth docutils literal notranslate"><span class="pre">builtins.list.copy()</span></code></p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">반환값</dt>
<dd class="field-odd"><p>a shallow copied list of this</p>
</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="koalanlp.data.Entity.corefGroup">
<code class="sig-name descname">corefGroup</code><em class="property"> = None</em><a class="headerlink" href="#koalanlp.data.Entity.corefGroup" title="정의 주소">¶</a></dt>
<dd><p>공지시어 해소 또는 대용어 분석 결과. <a class="reference internal" href="#koalanlp.data.Entity.getCorefGroup" title="koalanlp.data.Entity.getCorefGroup"><code class="xref py py-meth docutils literal notranslate"><span class="pre">getCorefGroup()</span></code></a> 참고.</p>
</dd></dl>

<dl class="method">
<dt id="koalanlp.data.Entity.count">
<code class="sig-name descname">count</code><span class="sig-paren">(</span><em class="sig-param">obj</em><span class="sig-paren">)</span><a class="headerlink" href="#koalanlp.data.Entity.count" title="정의 주소">¶</a></dt>
<dd><dl class="simple">
<dt>참고:</dt><dd><p><code class="xref py py-meth docutils literal notranslate"><span class="pre">builtins.list.count()</span></code></p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">매개변수</dt>
<dd class="field-odd"><p><strong>obj</strong> -- 세고자 하는 객체</p>
</dd>
<dt class="field-even">반환 형식</dt>
<dd class="field-even"><p>number</p>
</dd>
<dt class="field-odd">반환값</dt>
<dd class="field-odd"><p>return number of occurrences of value</p>
</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="koalanlp.data.Entity.fineLabel">
<code class="sig-name descname">fineLabel</code><em class="property"> = None</em><a class="headerlink" href="#koalanlp.data.Entity.fineLabel" title="정의 주소">¶</a></dt>
<dd><p>개체명 세분류 값</p>
</dd></dl>

<dl class="method">
<dt id="koalanlp.data.Entity.getCorefGroup">
<code class="sig-name descname">getCorefGroup</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#koalanlp.data.Entity.getCorefGroup" title="정의 주소">¶</a></dt>
<dd><p>이 개체명과 공통된 대상을 지칭하는 공통 지시어 또는 대용어들의 묶음을 제공합니다.</p>
<dl>
<dt>참고:</dt><dd><p><strong>공지시어 해소</strong> 는 문장 내 또는 문장 간에 같은 대상을 지칭하는 어구를 찾아 묶는 분석과정입니다.</p>
<p>예) '삼성그룹의 계열사인 삼성물산은 같은 그룹의 계열사인 삼성생명과 함께'라는 문장에서</p>
<ul class="simple">
<li><p>'삼성그룹'과 '같은 그룹'을 찾아 묶는 것을 말합니다.</p></li>
</ul>
<p><strong>영형대용어 분석</strong> 은 문장에서 생략된 기능어를 찾아 문장 내 또는 문장 간에 언급되어 있는 어구와 묶는 분석과정입니다.</p>
<p>예) '나는 밥을 먹었고, 영희도 먹었다'라는 문장에서,</p>
<ul class="simple">
<li><p>'먹었다'의 목적어인 '밥을'이 생략되어 있음을 찾는 것을 말합니다.</p></li>
</ul>
<p>아래를 참고해보세요.</p>
<ul class="simple">
<li><p><code class="xref py py-class docutils literal notranslate"><span class="pre">koalanlp.proc.CorefResolver</span></code> 공지시어 해소, 대용어 분석기 interface</p></li>
<li><p><a class="reference internal" href="#koalanlp.data.Sentence.getCorefGroups" title="koalanlp.data.Sentence.getCorefGroups"><code class="xref py py-meth docutils literal notranslate"><span class="pre">koalanlp.data.Sentence.getCorefGroups()</span></code></a> 문장 내에 포함된 개체명 묶음 [CoreferenceGroup]들의 목록을 반환하는 API</p></li>
<li><p><a class="reference internal" href="#koalanlp.data.CoreferenceGroup" title="koalanlp.data.CoreferenceGroup"><code class="xref py py-class docutils literal notranslate"><span class="pre">koalanlp.data.CoreferenceGroup</span></code></a> 동일한 대상을 지칭하는 개체명을 묶는 API</p></li>
</ul>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">반환 형식</dt>
<dd class="field-odd"><p><a class="reference internal" href="#koalanlp.data.CoreferenceGroup" title="koalanlp.data.CoreferenceGroup">CoreferenceGroup</a></p>
</dd>
<dt class="field-even">반환값</dt>
<dd class="field-even"><p>공통된 대상을 묶은 [CoreferenceGroup]. 없다면 None.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="koalanlp.data.Entity.getFineLabel">
<code class="sig-name descname">getFineLabel</code><span class="sig-paren">(</span><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#koalanlp.data.Entity.getFineLabel" title="정의 주소">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">반환 형식</dt>
<dd class="field-odd"><p>str</p>
</dd>
<dt class="field-even">반환값</dt>
<dd class="field-even"><p>개체명 세분류 값으로, [label]으로 시작하는 문자열.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="koalanlp.data.Entity.getLabel">
<code class="sig-name descname">getLabel</code><span class="sig-paren">(</span><span class="sig-paren">)</span> &#x2192; koalanlp.types.CoarseEntityType<a class="headerlink" href="#koalanlp.data.Entity.getLabel" title="정의 주소">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">반환 형식</dt>
<dd class="field-odd"><p><a class="reference internal" href="#koalanlp.types.CoarseEntityType" title="koalanlp.types.CoarseEntityType">CoarseEntityType</a></p>
</dd>
<dt class="field-even">반환값</dt>
<dd class="field-even"><p>개체명 대분류 값, [CoarseEntityType]에 기록된 개체명 중 하나.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="koalanlp.data.Entity.getOriginalLabel">
<code class="sig-name descname">getOriginalLabel</code><span class="sig-paren">(</span><span class="sig-paren">)</span> &#x2192; Optional[str]<a class="headerlink" href="#koalanlp.data.Entity.getOriginalLabel" title="정의 주소">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">반환 형식</dt>
<dd class="field-odd"><p>str</p>
</dd>
<dt class="field-even">반환값</dt>
<dd class="field-even"><p>원본 분석기가 제시한 개체명 분류의 값. 기본값은 null.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="koalanlp.data.Entity.getReference">
<code class="sig-name descname">getReference</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#koalanlp.data.Entity.getReference" title="정의 주소">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="koalanlp.data.Entity.getSurface">
<code class="sig-name descname">getSurface</code><span class="sig-paren">(</span><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#koalanlp.data.Entity.getSurface" title="정의 주소">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">반환 형식</dt>
<dd class="field-odd"><p>str</p>
</dd>
<dt class="field-even">반환값</dt>
<dd class="field-even"><p>개체명의 표면형 문자열.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="koalanlp.data.Entity.index">
<code class="sig-name descname">index</code><span class="sig-paren">(</span><em class="sig-param">obj</em>, <em class="sig-param">start=0</em>, <em class="sig-param">stop=None</em><span class="sig-paren">)</span><a class="headerlink" href="#koalanlp.data.Entity.index" title="정의 주소">¶</a></dt>
<dd><dl class="simple">
<dt>참고:</dt><dd><p><code class="xref py py-meth docutils literal notranslate"><span class="pre">builtins.list.index()</span></code></p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">매개변수</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>obj</strong> -- 찾고자 하는 객체</p></li>
<li><p><strong>start</strong> (<em>number</em>) -- 시작 지점</p></li>
<li><p><strong>stop</strong> (<em>Optional</em><em>[</em><em>number</em><em>]</em>) -- 종료 지점</p></li>
</ul>
</dd>
<dt class="field-even">반환 형식</dt>
<dd class="field-even"><p>number</p>
</dd>
<dt class="field-odd">반환값</dt>
<dd class="field-odd"><p>return first index of value. Raises ValueError if the value is not present.</p>
</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="koalanlp.data.Entity.label">
<code class="sig-name descname">label</code><em class="property"> = None</em><a class="headerlink" href="#koalanlp.data.Entity.label" title="정의 주소">¶</a></dt>
<dd><p>개체명 대분류 값</p>
</dd></dl>

<dl class="attribute">
<dt id="koalanlp.data.Entity.originalLabel">
<code class="sig-name descname">originalLabel</code><em class="property"> = None</em><a class="headerlink" href="#koalanlp.data.Entity.originalLabel" title="정의 주소">¶</a></dt>
<dd><p>원본 분석기가 제시한 개체명 분류의 값.</p>
</dd></dl>

<dl class="attribute">
<dt id="koalanlp.data.Entity.reference">
<code class="sig-name descname">reference</code><em class="property"> = None</em><a class="headerlink" href="#koalanlp.data.Entity.reference" title="정의 주소">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="koalanlp.data.Entity.surface">
<code class="sig-name descname">surface</code><em class="property"> = None</em><a class="headerlink" href="#koalanlp.data.Entity.surface" title="정의 주소">¶</a></dt>
<dd><p>개체명 표면형.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="koalanlp.data.CoreferenceGroup">
<em class="property">class </em><code class="sig-prename descclassname">koalanlp.data.</code><code class="sig-name descname">CoreferenceGroup</code><span class="sig-paren">(</span><em class="sig-param">entities</em><span class="sig-paren">)</span><a class="headerlink" href="#koalanlp.data.CoreferenceGroup" title="정의 주소">¶</a></dt>
<dd><p>공지시어 해소 또는 대용어 분석 결과를 저장할 class입니다.</p>
<dl>
<dt>참고:</dt><dd><p><strong>공지시어 해소</strong> 는 문장 내 또는 문장 간에 같은 대상을 지칭하는 어구를 찾아 묶는 분석과정입니다.</p>
<p>예) '삼성그룹의 계열사인 삼성물산은 같은 그룹의 계열사인 삼성생명과 함께'라는 문장에서</p>
<ul class="simple">
<li><p>'삼성그룹'과 '같은 그룹'을 찾아 묶는 것을 말합니다.</p></li>
</ul>
<p><strong>영형대용어 분석</strong> 은 문장에서 생략된 기능어를 찾아 문장 내 또는 문장 간에 언급되어 있는 어구와 묶는 분석과정입니다.</p>
<p>예) '나는 밥을 먹었고, 영희도 먹었다'라는 문장에서,</p>
<ul class="simple">
<li><p>'먹었다'의 목적어인 '밥을'이 생략되어 있음을 찾는 것을 말합니다.</p></li>
</ul>
<p>아래를 참고해보세요.
* <code class="xref py py-class docutils literal notranslate"><span class="pre">koalanlp.proc.CorefResolver</span></code> 공지시어 해소, 대용어 분석기 interface
* <a class="reference internal" href="#koalanlp.data.Sentence.getCorefGroups" title="koalanlp.data.Sentence.getCorefGroups"><code class="xref py py-meth docutils literal notranslate"><span class="pre">koalanlp.data.Sentence.getCorefGroups()</span></code></a> 문장 내에 포함된 개체명 묶음 [CoreferenceGroup]들의 목록을 반환하는 API
* <a class="reference internal" href="#koalanlp.data.Entity.getCorefGroup" title="koalanlp.data.Entity.getCorefGroup"><code class="xref py py-meth docutils literal notranslate"><span class="pre">koalanlp.data.Entity.getCorefGroup()</span></code></a> 각 개체명을 묶어 같은 지시 대상을 갖는 묶음인 [CoreferenceGroup]를 가져오는 API</p>
</dd>
</dl>
<dl class="method">
<dt id="koalanlp.data.CoreferenceGroup.__contains__">
<code class="sig-name descname">__contains__</code><span class="sig-paren">(</span><em class="sig-param">item</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#koalanlp.data.CoreferenceGroup.__contains__" title="정의 주소">¶</a></dt>
<dd><p>대상이 포함되는지 확인합니다.</p>
<dl class="field-list simple">
<dt class="field-odd">매개변수</dt>
<dd class="field-odd"><p><strong>item</strong> -- 포함되는지 확인할 대상</p>
</dd>
<dt class="field-even">반환 형식</dt>
<dd class="field-even"><p>bool</p>
</dd>
<dt class="field-odd">반환값</dt>
<dd class="field-odd"><p>해당 대상이 포함되면 true.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="koalanlp.data.CoreferenceGroup.__eq__">
<code class="sig-name descname">__eq__</code><span class="sig-paren">(</span><em class="sig-param">other</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#koalanlp.data.CoreferenceGroup.__eq__" title="정의 주소">¶</a></dt>
<dd><p>두 대상이 같은지 확인합니다.</p>
<dl class="field-list simple">
<dt class="field-odd">매개변수</dt>
<dd class="field-odd"><p><strong>other</strong> -- 이 객체와 비교할 다른 객체</p>
</dd>
<dt class="field-even">반환 형식</dt>
<dd class="field-even"><p>bool</p>
</dd>
<dt class="field-odd">반환값</dt>
<dd class="field-odd"><p>Java Reference가 같다면 true.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="koalanlp.data.CoreferenceGroup.__getitem__">
<code class="sig-name descname">__getitem__</code><span class="sig-paren">(</span><em class="sig-param">item</em><span class="sig-paren">)</span><a class="headerlink" href="#koalanlp.data.CoreferenceGroup.__getitem__" title="정의 주소">¶</a></dt>
<dd><p>포함된 대상을 가져옵니다.</p>
<dl class="field-list simple">
<dt class="field-odd">매개변수</dt>
<dd class="field-odd"><p><strong>item</strong> -- index의 번호 또는 slice</p>
</dd>
<dt class="field-even">반환값</dt>
<dd class="field-even"><p>지정된 위치에 있는 대상(들)</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="koalanlp.data.CoreferenceGroup.__hash__">
<code class="sig-name descname">__hash__</code><span class="sig-paren">(</span><span class="sig-paren">)</span> &#x2192; int<a class="headerlink" href="#koalanlp.data.CoreferenceGroup.__hash__" title="정의 주소">¶</a></dt>
<dd><p>해쉬 값을 계산합니다.</p>
<dl class="field-list simple">
<dt class="field-odd">반환 형식</dt>
<dd class="field-odd"><p>int</p>
</dd>
<dt class="field-even">반환값</dt>
<dd class="field-even"><p>Java Reference의 Hash code</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="koalanlp.data.CoreferenceGroup.__iter__">
<code class="sig-name descname">__iter__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#koalanlp.data.CoreferenceGroup.__iter__" title="정의 주소">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">반환 형식</dt>
<dd class="field-odd"><p>iter</p>
</dd>
<dt class="field-even">반환값</dt>
<dd class="field-even"><p>포함된 대상을 순회하는 iterator</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="koalanlp.data.CoreferenceGroup.__len__">
<code class="sig-name descname">__len__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#koalanlp.data.CoreferenceGroup.__len__" title="정의 주소">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">반환 형식</dt>
<dd class="field-odd"><p>int</p>
</dd>
<dt class="field-even">반환값</dt>
<dd class="field-even"><p>포함된 대상의 개수</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="koalanlp.data.CoreferenceGroup.__repr__">
<code class="sig-name descname">__repr__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#koalanlp.data.CoreferenceGroup.__repr__" title="정의 주소">¶</a></dt>
<dd><p>Return repr(self).</p>
</dd></dl>

<dl class="method">
<dt id="koalanlp.data.CoreferenceGroup.copy">
<code class="sig-name descname">copy</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#koalanlp.data.CoreferenceGroup.copy" title="정의 주소">¶</a></dt>
<dd><dl class="simple">
<dt>참고:</dt><dd><p><code class="xref py py-meth docutils literal notranslate"><span class="pre">builtins.list.copy()</span></code></p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">반환값</dt>
<dd class="field-odd"><p>a shallow copied list of this</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="koalanlp.data.CoreferenceGroup.count">
<code class="sig-name descname">count</code><span class="sig-paren">(</span><em class="sig-param">obj</em><span class="sig-paren">)</span><a class="headerlink" href="#koalanlp.data.CoreferenceGroup.count" title="정의 주소">¶</a></dt>
<dd><dl class="simple">
<dt>참고:</dt><dd><p><code class="xref py py-meth docutils literal notranslate"><span class="pre">builtins.list.count()</span></code></p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">매개변수</dt>
<dd class="field-odd"><p><strong>obj</strong> -- 세고자 하는 객체</p>
</dd>
<dt class="field-even">반환 형식</dt>
<dd class="field-even"><p>number</p>
</dd>
<dt class="field-odd">반환값</dt>
<dd class="field-odd"><p>return number of occurrences of value</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="koalanlp.data.CoreferenceGroup.getReference">
<code class="sig-name descname">getReference</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#koalanlp.data.CoreferenceGroup.getReference" title="정의 주소">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="koalanlp.data.CoreferenceGroup.index">
<code class="sig-name descname">index</code><span class="sig-paren">(</span><em class="sig-param">obj</em>, <em class="sig-param">start=0</em>, <em class="sig-param">stop=None</em><span class="sig-paren">)</span><a class="headerlink" href="#koalanlp.data.CoreferenceGroup.index" title="정의 주소">¶</a></dt>
<dd><dl class="simple">
<dt>참고:</dt><dd><p><code class="xref py py-meth docutils literal notranslate"><span class="pre">builtins.list.index()</span></code></p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">매개변수</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>obj</strong> -- 찾고자 하는 객체</p></li>
<li><p><strong>start</strong> (<em>number</em>) -- 시작 지점</p></li>
<li><p><strong>stop</strong> (<em>Optional</em><em>[</em><em>number</em><em>]</em>) -- 종료 지점</p></li>
</ul>
</dd>
<dt class="field-even">반환 형식</dt>
<dd class="field-even"><p>number</p>
</dd>
<dt class="field-odd">반환값</dt>
<dd class="field-odd"><p>return first index of value. Raises ValueError if the value is not present.</p>
</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="koalanlp.data.CoreferenceGroup.reference">
<code class="sig-name descname">reference</code><em class="property"> = None</em><a class="headerlink" href="#koalanlp.data.CoreferenceGroup.reference" title="정의 주소">¶</a></dt>
<dd><p>Java CoreferenceGroup reference</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="koalanlp.data.SyntaxTree">
<em class="property">class </em><code class="sig-prename descclassname">koalanlp.data.</code><code class="sig-name descname">SyntaxTree</code><span class="sig-paren">(</span><em class="sig-param">label: Union[str, koalanlp.types.PhraseTag], terminal=None, children=None, originalLabel=None</em><span class="sig-paren">)</span><a class="headerlink" href="#koalanlp.data.SyntaxTree" title="정의 주소">¶</a></dt>
<dd><p>구문구조 분석의 결과를 저장할 [Property].</p>
<dl>
<dt>참고:</dt><dd><p><strong>구문구조 분석</strong> 은 문장의 구성요소들(어절, 구, 절)이 이루는 문법적 구조를 분석하는 방법입니다.</p>
<p>예) '나는 밥을 먹었고, 영희는 짐을 쌌다'라는 문장에는 2개의 절이 있습니다</p>
<ul class="simple">
<li><p>나는 밥을 먹었고</p></li>
<li><p>영희는 짐을 쌌다</p></li>
</ul>
<p>각 절은 3개의 구를 포함합니다</p>
<ul class="simple">
<li><p>나는, 밥을, 영희는, 짐을: 체언구</p></li>
<li><p>먹었고, 쌌다: 용언구</p></li>
</ul>
<p>아래를 참고해보세요.</p>
<ul class="simple">
<li><p><a class="reference internal" href="#koalanlp.proc.Parser" title="koalanlp.proc.Parser"><code class="xref py py-class docutils literal notranslate"><span class="pre">koalanlp.proc.Parser</span></code></a> 구문구조 분석을 수행하는 interface.</p></li>
<li><p><a class="reference internal" href="#koalanlp.data.Word.getPhrase" title="koalanlp.data.Word.getPhrase"><code class="xref py py-meth docutils literal notranslate"><span class="pre">koalanlp.data.Word.getPhrase()</span></code></a> 어절이 직접 속하는 가장 작은 구구조 [SyntaxTree]를 가져오는 API</p></li>
<li><p><a class="reference internal" href="#koalanlp.data.Sentence.getSyntaxTree" title="koalanlp.data.Sentence.getSyntaxTree"><code class="xref py py-meth docutils literal notranslate"><span class="pre">koalanlp.data.Sentence.getSyntaxTree()</span></code></a> 전체 문장을 분석한 [SyntaxTree]를 가져오는 API</p></li>
<li><p><a class="reference internal" href="#koalanlp.types.PhraseTag" title="koalanlp.types.PhraseTag"><code class="xref py py-class docutils literal notranslate"><span class="pre">koalanlp.types.PhraseTag</span></code></a> 구구조의 형태 분류를 갖는 Enum 값</p></li>
</ul>
</dd>
</dl>
<dl class="method">
<dt id="koalanlp.data.SyntaxTree.__contains__">
<code class="sig-name descname">__contains__</code><span class="sig-paren">(</span><em class="sig-param">item</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#koalanlp.data.SyntaxTree.__contains__" title="정의 주소">¶</a></dt>
<dd><p>대상이 포함되는지 확인합니다.</p>
<dl class="field-list simple">
<dt class="field-odd">매개변수</dt>
<dd class="field-odd"><p><strong>item</strong> -- 포함되는지 확인할 대상</p>
</dd>
<dt class="field-even">반환 형식</dt>
<dd class="field-even"><p>bool</p>
</dd>
<dt class="field-odd">반환값</dt>
<dd class="field-odd"><p>해당 대상이 포함되면 true.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="koalanlp.data.SyntaxTree.__eq__">
<code class="sig-name descname">__eq__</code><span class="sig-paren">(</span><em class="sig-param">other</em><span class="sig-paren">)</span><a class="headerlink" href="#koalanlp.data.SyntaxTree.__eq__" title="정의 주소">¶</a></dt>
<dd><p>두 대상이 같은지 확인합니다.</p>
<dl class="field-list simple">
<dt class="field-odd">매개변수</dt>
<dd class="field-odd"><p><strong>other</strong> -- 이 객체와 비교할 다른 객체</p>
</dd>
<dt class="field-even">반환 형식</dt>
<dd class="field-even"><p>bool</p>
</dd>
<dt class="field-odd">반환값</dt>
<dd class="field-odd"><p>Java Reference가 같다면 true.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="koalanlp.data.SyntaxTree.__getitem__">
<code class="sig-name descname">__getitem__</code><span class="sig-paren">(</span><em class="sig-param">item</em><span class="sig-paren">)</span><a class="headerlink" href="#koalanlp.data.SyntaxTree.__getitem__" title="정의 주소">¶</a></dt>
<dd><p>포함된 대상을 가져옵니다.</p>
<dl class="field-list simple">
<dt class="field-odd">매개변수</dt>
<dd class="field-odd"><p><strong>item</strong> -- index의 번호 또는 slice</p>
</dd>
<dt class="field-even">반환값</dt>
<dd class="field-even"><p>지정된 위치에 있는 대상(들)</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="koalanlp.data.SyntaxTree.__hash__">
<code class="sig-name descname">__hash__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#koalanlp.data.SyntaxTree.__hash__" title="정의 주소">¶</a></dt>
<dd><p>해쉬 값을 계산합니다.</p>
<dl class="field-list simple">
<dt class="field-odd">반환 형식</dt>
<dd class="field-odd"><p>int</p>
</dd>
<dt class="field-even">반환값</dt>
<dd class="field-even"><p>Java Reference의 Hash code</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="koalanlp.data.SyntaxTree.__iter__">
<code class="sig-name descname">__iter__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#koalanlp.data.SyntaxTree.__iter__" title="정의 주소">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">반환 형식</dt>
<dd class="field-odd"><p>iter</p>
</dd>
<dt class="field-even">반환값</dt>
<dd class="field-even"><p>포함된 대상을 순회하는 iterator</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="koalanlp.data.SyntaxTree.__len__">
<code class="sig-name descname">__len__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#koalanlp.data.SyntaxTree.__len__" title="정의 주소">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">반환 형식</dt>
<dd class="field-odd"><p>int</p>
</dd>
<dt class="field-even">반환값</dt>
<dd class="field-even"><p>포함된 대상의 개수</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="koalanlp.data.SyntaxTree.__repr__">
<code class="sig-name descname">__repr__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#koalanlp.data.SyntaxTree.__repr__" title="정의 주소">¶</a></dt>
<dd><p>Return repr(self).</p>
</dd></dl>

<dl class="method">
<dt id="koalanlp.data.SyntaxTree.copy">
<code class="sig-name descname">copy</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#koalanlp.data.SyntaxTree.copy" title="정의 주소">¶</a></dt>
<dd><dl class="simple">
<dt>참고:</dt><dd><p><code class="xref py py-meth docutils literal notranslate"><span class="pre">builtins.list.copy()</span></code></p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">반환값</dt>
<dd class="field-odd"><p>a shallow copied list of this</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="koalanlp.data.SyntaxTree.count">
<code class="sig-name descname">count</code><span class="sig-paren">(</span><em class="sig-param">obj</em><span class="sig-paren">)</span><a class="headerlink" href="#koalanlp.data.SyntaxTree.count" title="정의 주소">¶</a></dt>
<dd><dl class="simple">
<dt>참고:</dt><dd><p><code class="xref py py-meth docutils literal notranslate"><span class="pre">builtins.list.count()</span></code></p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">매개변수</dt>
<dd class="field-odd"><p><strong>obj</strong> -- 세고자 하는 객체</p>
</dd>
<dt class="field-even">반환 형식</dt>
<dd class="field-even"><p>number</p>
</dd>
<dt class="field-odd">반환값</dt>
<dd class="field-odd"><p>return number of occurrences of value</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="koalanlp.data.SyntaxTree.getLabel">
<code class="sig-name descname">getLabel</code><span class="sig-paren">(</span><span class="sig-paren">)</span> &#x2192; koalanlp.types.PhraseTag<a class="headerlink" href="#koalanlp.data.SyntaxTree.getLabel" title="정의 주소">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">반환 형식</dt>
<dd class="field-odd"><p><a class="reference internal" href="#koalanlp.types.PhraseTag" title="koalanlp.types.PhraseTag">PhraseTag</a></p>
</dd>
<dt class="field-even">반환값</dt>
<dd class="field-even"><p>구문구조 표지자</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="koalanlp.data.SyntaxTree.getNonTerminals">
<code class="sig-name descname">getNonTerminals</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#koalanlp.data.SyntaxTree.getNonTerminals" title="정의 주소">¶</a></dt>
<dd><p>이 노드의 Non-terminal 자식 노드를 모읍니다.</p>
<ul class="simple">
<li><p>이 함수는 읽기의 편의를 위한 syntactic sugar입니다. 즉 다음 구문은 동일합니다.</p></li>
</ul>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">x</span><span class="o">.</span><span class="n">getNonTerminals</span><span class="p">():</span>
    <span class="o">...</span>
<span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">x</span><span class="p">:</span>
    <span class="o">...</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">반환값</dt>
<dd class="field-odd"><p>같은 타입의 부모 노드 또는 null</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="koalanlp.data.SyntaxTree.getOriginalLabel">
<code class="sig-name descname">getOriginalLabel</code><span class="sig-paren">(</span><span class="sig-paren">)</span> &#x2192; Optional[str]<a class="headerlink" href="#koalanlp.data.SyntaxTree.getOriginalLabel" title="정의 주소">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">반환 형식</dt>
<dd class="field-odd"><p>str</p>
</dd>
<dt class="field-even">반환값</dt>
<dd class="field-even"><p>원본 분석기의 표지자 String 값. 기본값은 None.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="koalanlp.data.SyntaxTree.getParent">
<code class="sig-name descname">getParent</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#koalanlp.data.SyntaxTree.getParent" title="정의 주소">¶</a></dt>
<dd><p>부모 노드를 반환합니다.</p>
<ul class="simple">
<li><p>부모 노드가 초기화되지 않은 경우 null을 반환합니다.</p></li>
</ul>
<dl class="field-list simple">
<dt class="field-odd">반환값</dt>
<dd class="field-odd"><p>같은 타입의 부모 노드 또는 null</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="koalanlp.data.SyntaxTree.getReference">
<code class="sig-name descname">getReference</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#koalanlp.data.SyntaxTree.getReference" title="정의 주소">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="koalanlp.data.SyntaxTree.getTerminal">
<code class="sig-name descname">getTerminal</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#koalanlp.data.SyntaxTree.getTerminal" title="정의 주소">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">반환 형식</dt>
<dd class="field-odd"><p><a class="reference internal" href="#koalanlp.data.Word" title="koalanlp.data.Word">Word</a></p>
</dd>
<dt class="field-even">반환값</dt>
<dd class="field-even"><p>트리의 노드에서 연결되는 [Word] 또는 None</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="koalanlp.data.SyntaxTree.getTerminals">
<code class="sig-name descname">getTerminals</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#koalanlp.data.SyntaxTree.getTerminals" title="정의 주소">¶</a></dt>
<dd><p>이 노드를 포함해 모든 하위 Non-terminal 노드들에 속하는 terminal node들을 모읍니다.</p>
<ul class="simple">
<li><p>구문분석 구조에서는 이 구문구조에 속하는 어절의 모음입니다.</p></li>
</ul>
<dl class="field-list simple">
<dt class="field-odd">반환 형식</dt>
<dd class="field-odd"><p>List[<a class="reference internal" href="#koalanlp.data.Word" title="koalanlp.data.Word">Word</a>]</p>
</dd>
<dt class="field-even">반환값</dt>
<dd class="field-even"><p>Terminal node의 목록</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="koalanlp.data.SyntaxTree.getTreeString">
<code class="sig-name descname">getTreeString</code><span class="sig-paren">(</span><em class="sig-param">depth=0</em>, <em class="sig-param">buffer=''</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#koalanlp.data.SyntaxTree.getTreeString" title="정의 주소">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">반환 형식</dt>
<dd class="field-odd"><p>str</p>
</dd>
<dt class="field-even">매개변수</dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>depth</strong> (<em>int</em>) -- 들여쓰기할 수준입니다. 숫자만큼 들여쓰기됩니다. (기본값 0)</p></li>
<li><p><strong>buffer</strong> (<em>str</em>) -- 결과를 저장할 버퍼입니다.</p></li>
</ul>
</dd>
<dt class="field-odd">반환값</dt>
<dd class="field-odd"><p>트리구조의 표현을 문자열로 돌려줍니다.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="koalanlp.data.SyntaxTree.hasNonTerminals">
<code class="sig-name descname">hasNonTerminals</code><span class="sig-paren">(</span><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#koalanlp.data.SyntaxTree.hasNonTerminals" title="정의 주소">¶</a></dt>
<dd><p>이 노드가 (terminal node를 제외하고) 자식 노드를 갖는지 확인합니다.</p>
<ul class="simple">
<li><p>구문분석 구조에서 terminal node는 [Word]가 됩니다.</p></li>
</ul>
<dl class="field-list simple">
<dt class="field-odd">반환 형식</dt>
<dd class="field-odd"><p>bool</p>
</dd>
<dt class="field-even">반환값</dt>
<dd class="field-even"><p>자식노드가 있다면 True</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="koalanlp.data.SyntaxTree.index">
<code class="sig-name descname">index</code><span class="sig-paren">(</span><em class="sig-param">obj</em>, <em class="sig-param">start=0</em>, <em class="sig-param">stop=None</em><span class="sig-paren">)</span><a class="headerlink" href="#koalanlp.data.SyntaxTree.index" title="정의 주소">¶</a></dt>
<dd><dl class="simple">
<dt>참고:</dt><dd><p><code class="xref py py-meth docutils literal notranslate"><span class="pre">builtins.list.index()</span></code></p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">매개변수</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>obj</strong> -- 찾고자 하는 객체</p></li>
<li><p><strong>start</strong> (<em>number</em>) -- 시작 지점</p></li>
<li><p><strong>stop</strong> (<em>Optional</em><em>[</em><em>number</em><em>]</em>) -- 종료 지점</p></li>
</ul>
</dd>
<dt class="field-even">반환 형식</dt>
<dd class="field-even"><p>number</p>
</dd>
<dt class="field-odd">반환값</dt>
<dd class="field-odd"><p>return first index of value. Raises ValueError if the value is not present.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="koalanlp.data.SyntaxTree.isRoot">
<code class="sig-name descname">isRoot</code><span class="sig-paren">(</span><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#koalanlp.data.SyntaxTree.isRoot" title="정의 주소">¶</a></dt>
<dd><p>이 노드가 최상위 노드인지 확인합니다.</p>
<dl class="field-list simple">
<dt class="field-odd">반환 형식</dt>
<dd class="field-odd"><p>bool</p>
</dd>
<dt class="field-even">반환값</dt>
<dd class="field-even"><p>최상위 노드인 경우 true</p>
</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="koalanlp.data.SyntaxTree.label">
<code class="sig-name descname">label</code><em class="property"> = None</em><a class="headerlink" href="#koalanlp.data.SyntaxTree.label" title="정의 주소">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="koalanlp.data.SyntaxTree.originalLabel">
<code class="sig-name descname">originalLabel</code><em class="property"> = None</em><a class="headerlink" href="#koalanlp.data.SyntaxTree.originalLabel" title="정의 주소">¶</a></dt>
<dd><p>원본 분석기의 표지자 값</p>
</dd></dl>

<dl class="attribute">
<dt id="koalanlp.data.SyntaxTree.parent">
<code class="sig-name descname">parent</code><em class="property"> = None</em><a class="headerlink" href="#koalanlp.data.SyntaxTree.parent" title="정의 주소">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="koalanlp.data.SyntaxTree.reference">
<code class="sig-name descname">reference</code><em class="property"> = None</em><a class="headerlink" href="#koalanlp.data.SyntaxTree.reference" title="정의 주소">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="koalanlp.data.SyntaxTree.terminal">
<code class="sig-name descname">terminal</code><em class="property"> = None</em><a class="headerlink" href="#koalanlp.data.SyntaxTree.terminal" title="정의 주소">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="koalanlp.data.DepEdge">
<em class="property">class </em><code class="sig-prename descclassname">koalanlp.data.</code><code class="sig-name descname">DepEdge</code><span class="sig-paren">(</span><em class="sig-param">governor=None</em>, <em class="sig-param">dependent=None</em>, <em class="sig-param">type=None</em>, <em class="sig-param">depType=None</em>, <em class="sig-param">originalLabel: str = None</em><span class="sig-paren">)</span><a class="headerlink" href="#koalanlp.data.DepEdge" title="정의 주소">¶</a></dt>
<dd><p>의존구문구조 분석의 결과.</p>
<dl>
<dt>참고:</dt><dd><p><strong>의존구조 분석</strong> 은 문장의 구성 어절들이 의존 또는 기능하는 관계를 분석하는 방법입니다.</p>
<p>예) '나는 밥을 먹었고, 영희는 짐을 쌌다'라는 문장에는</p>
<p>가장 마지막 단어인 '쌌다'가 핵심 어구가 되며,</p>
<ul class="simple">
<li><p>'먹었고'가 '쌌다'와 대등하게 연결되고</p></li>
<li><p>'나는'은 '먹었고'의 주어로 기능하며</p></li>
<li><p>'밥을'은 '먹었고'의 목적어로 기능합니다.</p></li>
<li><p>'영희는'은 '쌌다'의 주어로 기능하고,</p></li>
<li><p>'짐을'은 '쌌다'의 목적어로 기능합니다.</p></li>
</ul>
<p>아래를 참고해보세요.</p>
<ul class="simple">
<li><p><a class="reference internal" href="#koalanlp.proc.Parser" title="koalanlp.proc.Parser"><code class="xref py py-class docutils literal notranslate"><span class="pre">koalanlp.proc.Parser</span></code></a> 의존구조 분석을 수행하는 interface.</p></li>
<li><p><a class="reference internal" href="#koalanlp.data.Word.getDependentEdges" title="koalanlp.data.Word.getDependentEdges"><code class="xref py py-meth docutils literal notranslate"><span class="pre">koalanlp.data.Word.getDependentEdges()</span></code></a> 어절이 직접 지배하는 하위 의존구조 [DepEdge]의 목록을 가져오는 API</p></li>
<li><p><a class="reference internal" href="#koalanlp.data.Word.getGovernorEdge" title="koalanlp.data.Word.getGovernorEdge"><code class="xref py py-meth docutils literal notranslate"><span class="pre">koalanlp.data.Word.getGovernorEdge()</span></code></a> 어절이 지배당하는 상위 의존구조 [DepEdge]를 가져오는 API</p></li>
<li><p><a class="reference internal" href="#koalanlp.data.Sentence.getDependencies" title="koalanlp.data.Sentence.getDependencies"><code class="xref py py-meth docutils literal notranslate"><span class="pre">koalanlp.data.Sentence.getDependencies()</span></code></a> 전체 문장을 분석한 의존구조 [DepEdge]의 목록을 가져오는 API</p></li>
<li><p><a class="reference internal" href="#koalanlp.types.PhraseTag" title="koalanlp.types.PhraseTag"><code class="xref py py-meth docutils literal notranslate"><span class="pre">koalanlp.types.PhraseTag()</span></code></a> 의존구조의 형태 분류를 갖는 Enum 값 (구구조 분류와 같음)</p></li>
<li><p><a class="reference internal" href="#koalanlp.types.DependencyTag" title="koalanlp.types.DependencyTag"><code class="xref py py-meth docutils literal notranslate"><span class="pre">koalanlp.types.DependencyTag()</span></code></a> 의존구조의 기능 분류를 갖는 Enum 값</p></li>
</ul>
</dd>
</dl>
<dl class="method">
<dt id="koalanlp.data.DepEdge.__eq__">
<code class="sig-name descname">__eq__</code><span class="sig-paren">(</span><em class="sig-param">other</em><span class="sig-paren">)</span><a class="headerlink" href="#koalanlp.data.DepEdge.__eq__" title="정의 주소">¶</a></dt>
<dd><p>Return self==value.</p>
</dd></dl>

<dl class="method">
<dt id="koalanlp.data.DepEdge.__hash__">
<code class="sig-name descname">__hash__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#koalanlp.data.DepEdge.__hash__" title="정의 주소">¶</a></dt>
<dd><p>Return hash(self).</p>
</dd></dl>

<dl class="method">
<dt id="koalanlp.data.DepEdge.__repr__">
<code class="sig-name descname">__repr__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#koalanlp.data.DepEdge.__repr__" title="정의 주소">¶</a></dt>
<dd><p>Return repr(self).</p>
</dd></dl>

<dl class="attribute">
<dt id="koalanlp.data.DepEdge.depType">
<code class="sig-name descname">depType</code><em class="property"> = None</em><a class="headerlink" href="#koalanlp.data.DepEdge.depType" title="정의 주소">¶</a></dt>
<dd><p>의존구문구조 표지자 값</p>
</dd></dl>

<dl class="attribute">
<dt id="koalanlp.data.DepEdge.dependent">
<code class="sig-name descname">dependent</code><em class="property"> = None</em><a class="headerlink" href="#koalanlp.data.DepEdge.dependent" title="정의 주소">¶</a></dt>
<dd><p>의존구문구조의 피지배소</p>
</dd></dl>

<dl class="attribute">
<dt id="koalanlp.data.DepEdge.dest">
<code class="sig-name descname">dest</code><em class="property"> = None</em><a class="headerlink" href="#koalanlp.data.DepEdge.dest" title="정의 주소">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="koalanlp.data.DepEdge.getDepType">
<code class="sig-name descname">getDepType</code><span class="sig-paren">(</span><span class="sig-paren">)</span> &#x2192; Optional[koalanlp.types.DependencyTag]<a class="headerlink" href="#koalanlp.data.DepEdge.getDepType" title="정의 주소">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">반환 형식</dt>
<dd class="field-odd"><p><a class="reference internal" href="#koalanlp.types.DependencyTag" title="koalanlp.types.DependencyTag">DependencyTag</a></p>
</dd>
<dt class="field-even">반환값</dt>
<dd class="field-even"><p>의존기능 표지자, [DependencyTag] Enum 값. 별도의 기능이 지정되지 않으면 None. (ETRI 표준안은 구구조+의존기능으로 의존구문구조를 표기함)</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="koalanlp.data.DepEdge.getDependent">
<code class="sig-name descname">getDependent</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#koalanlp.data.DepEdge.getDependent" title="정의 주소">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">반환 형식</dt>
<dd class="field-odd"><p><a class="reference internal" href="#koalanlp.data.Word" title="koalanlp.data.Word">Word</a></p>
</dd>
<dt class="field-even">반환값</dt>
<dd class="field-even"><p>의존구조의 피지배소 [Word]</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="koalanlp.data.DepEdge.getDest">
<code class="sig-name descname">getDest</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#koalanlp.data.DepEdge.getDest" title="정의 주소">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">반환값</dt>
<dd class="field-odd"><p>Edge의 종점. 의존구문분석인 경우 피지배소, 의미역인 경우 논항.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="koalanlp.data.DepEdge.getGovernor">
<code class="sig-name descname">getGovernor</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#koalanlp.data.DepEdge.getGovernor" title="정의 주소">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">반환 형식</dt>
<dd class="field-odd"><p><a class="reference internal" href="#koalanlp.data.Word" title="koalanlp.data.Word">Word</a></p>
</dd>
<dt class="field-even">반환값</dt>
<dd class="field-even"><p>의존구조의 지배소 [Word]. 문장의 Root에 해당하는 경우 None.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="koalanlp.data.DepEdge.getLabel">
<code class="sig-name descname">getLabel</code><span class="sig-paren">(</span><span class="sig-paren">)</span> &#x2192; koalanlp.types.DependencyTag<a class="headerlink" href="#koalanlp.data.DepEdge.getLabel" title="정의 주소">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">반환 형식</dt>
<dd class="field-odd"><p><a class="reference internal" href="#koalanlp.types.DependencyTag" title="koalanlp.types.DependencyTag">DependencyTag</a></p>
</dd>
<dt class="field-even">반환값</dt>
<dd class="field-even"><p>Edge가 나타내는 관계.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="koalanlp.data.DepEdge.getOriginalLabel">
<code class="sig-name descname">getOriginalLabel</code><span class="sig-paren">(</span><span class="sig-paren">)</span> &#x2192; Optional[str]<a class="headerlink" href="#koalanlp.data.DepEdge.getOriginalLabel" title="정의 주소">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">반환 형식</dt>
<dd class="field-odd"><p>str</p>
</dd>
<dt class="field-even">반환값</dt>
<dd class="field-even"><p>원본 분석기의 표지자 String 값. 기본값은 None.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="koalanlp.data.DepEdge.getReference">
<code class="sig-name descname">getReference</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#koalanlp.data.DepEdge.getReference" title="정의 주소">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="koalanlp.data.DepEdge.getSrc">
<code class="sig-name descname">getSrc</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#koalanlp.data.DepEdge.getSrc" title="정의 주소">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">반환값</dt>
<dd class="field-odd"><p>Edge의 시작점. 의존구문분석인 경우 지배소, 의미역인 경우 동사.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="koalanlp.data.DepEdge.getType">
<code class="sig-name descname">getType</code><span class="sig-paren">(</span><span class="sig-paren">)</span> &#x2192; koalanlp.types.PhraseTag<a class="headerlink" href="#koalanlp.data.DepEdge.getType" title="정의 주소">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">반환 형식</dt>
<dd class="field-odd"><p><a class="reference internal" href="#koalanlp.types.PhraseTag" title="koalanlp.types.PhraseTag">PhraseTag</a></p>
</dd>
<dt class="field-even">반환값</dt>
<dd class="field-even"><p>구구조 표지자, [PhraseTag] Enum 값 (ETRI 표준안은 구구조+의존기능으로 의존구문구조를 표기함)</p>
</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="koalanlp.data.DepEdge.governor">
<code class="sig-name descname">governor</code><em class="property"> = None</em><a class="headerlink" href="#koalanlp.data.DepEdge.governor" title="정의 주소">¶</a></dt>
<dd><p>의존구문구조의 지배소</p>
</dd></dl>

<dl class="attribute">
<dt id="koalanlp.data.DepEdge.label">
<code class="sig-name descname">label</code><em class="property"> = None</em><a class="headerlink" href="#koalanlp.data.DepEdge.label" title="정의 주소">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="koalanlp.data.DepEdge.originalLabel">
<code class="sig-name descname">originalLabel</code><em class="property"> = None</em><a class="headerlink" href="#koalanlp.data.DepEdge.originalLabel" title="정의 주소">¶</a></dt>
<dd><p>원본 분석기의 표지자 값</p>
</dd></dl>

<dl class="attribute">
<dt id="koalanlp.data.DepEdge.reference">
<code class="sig-name descname">reference</code><em class="property"> = None</em><a class="headerlink" href="#koalanlp.data.DepEdge.reference" title="정의 주소">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="koalanlp.data.DepEdge.src">
<code class="sig-name descname">src</code><em class="property"> = None</em><a class="headerlink" href="#koalanlp.data.DepEdge.src" title="정의 주소">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="koalanlp.data.DepEdge.type">
<code class="sig-name descname">type</code><em class="property"> = None</em><a class="headerlink" href="#koalanlp.data.DepEdge.type" title="정의 주소">¶</a></dt>
<dd><p>구문구조 표지자 값</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="koalanlp.data.RoleEdge">
<em class="property">class </em><code class="sig-prename descclassname">koalanlp.data.</code><code class="sig-name descname">RoleEdge</code><span class="sig-paren">(</span><em class="sig-param">predicate</em>, <em class="sig-param">argument</em>, <em class="sig-param">label</em>, <em class="sig-param">modifiers: List = None</em>, <em class="sig-param">originalLabel: str = None</em><span class="sig-paren">)</span><a class="headerlink" href="#koalanlp.data.RoleEdge" title="정의 주소">¶</a></dt>
<dd><p>의미역 구조 분석의 결과.</p>
<dl>
<dt>참고:</dt><dd><p><strong>의미역 결정</strong> 은 문장의 구성 어절들의 역할/기능을 분석하는 방법입니다.</p>
<p>예) '나는 밥을 어제 집에서 먹었다'라는 문장에는</p>
<p>동사 '먹었다'를 중심으로</p>
<ul class="simple">
<li><p>'나는'은 동작의 주체를,</p></li>
<li><p>'밥을'은 동작의 대상을,</p></li>
<li><p>'어제'는 동작의 시점을</p></li>
<li><p>'집에서'는 동작의 장소를 나타냅니다.</p></li>
</ul>
<p>아래를 참고해보세요.</p>
<ul class="simple">
<li><p><a class="reference internal" href="#koalanlp.proc.RoleLabeler" title="koalanlp.proc.RoleLabeler"><code class="xref py py-class docutils literal notranslate"><span class="pre">koalanlp.proc.RoleLabeler</span></code></a> 의미역 분석을 수행하는 interface.</p></li>
<li><p><a class="reference internal" href="#koalanlp.data.Word.getArgumentRoles" title="koalanlp.data.Word.getArgumentRoles"><code class="xref py py-meth docutils literal notranslate"><span class="pre">koalanlp.data.Word.getArgumentRoles()</span></code></a> 어절이 술어인 논항들의 [RoleEdge] 목록을 가져오는 API</p></li>
<li><p><a class="reference internal" href="#koalanlp.data.Word.getPredicateRoles" title="koalanlp.data.Word.getPredicateRoles"><code class="xref py py-meth docutils literal notranslate"><span class="pre">koalanlp.data.Word.getPredicateRoles()</span></code></a> 어절이 논항인 [RoleEdge]의 술어를 가져오는 API</p></li>
<li><p><a class="reference internal" href="#koalanlp.data.Sentence.getRoles" title="koalanlp.data.Sentence.getRoles"><code class="xref py py-meth docutils literal notranslate"><span class="pre">koalanlp.data.Sentence.getRoles()</span></code></a> 전체 문장을 분석한 의미역 구조 [RoleEdge]를 가져오는 API</p></li>
<li><p><a class="reference internal" href="#koalanlp.types.RoleType" title="koalanlp.types.RoleType"><code class="xref py py-class docutils literal notranslate"><span class="pre">koalanlp.types.RoleType</span></code></a> 의미역 분류를 갖는 Enum 값</p></li>
</ul>
</dd>
</dl>
<dl class="method">
<dt id="koalanlp.data.RoleEdge.__eq__">
<code class="sig-name descname">__eq__</code><span class="sig-paren">(</span><em class="sig-param">other</em><span class="sig-paren">)</span><a class="headerlink" href="#koalanlp.data.RoleEdge.__eq__" title="정의 주소">¶</a></dt>
<dd><p>Return self==value.</p>
</dd></dl>

<dl class="method">
<dt id="koalanlp.data.RoleEdge.__hash__">
<code class="sig-name descname">__hash__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#koalanlp.data.RoleEdge.__hash__" title="정의 주소">¶</a></dt>
<dd><p>Return hash(self).</p>
</dd></dl>

<dl class="method">
<dt id="koalanlp.data.RoleEdge.__repr__">
<code class="sig-name descname">__repr__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#koalanlp.data.RoleEdge.__repr__" title="정의 주소">¶</a></dt>
<dd><p>Return repr(self).</p>
</dd></dl>

<dl class="attribute">
<dt id="koalanlp.data.RoleEdge.argument">
<code class="sig-name descname">argument</code><em class="property"> = None</em><a class="headerlink" href="#koalanlp.data.RoleEdge.argument" title="정의 주소">¶</a></dt>
<dd><p>의미역 구조의 논항</p>
</dd></dl>

<dl class="attribute">
<dt id="koalanlp.data.RoleEdge.dest">
<code class="sig-name descname">dest</code><em class="property"> = None</em><a class="headerlink" href="#koalanlp.data.RoleEdge.dest" title="정의 주소">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="koalanlp.data.RoleEdge.getArgument">
<code class="sig-name descname">getArgument</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#koalanlp.data.RoleEdge.getArgument" title="정의 주소">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">반환 형식</dt>
<dd class="field-odd"><p><a class="reference internal" href="#koalanlp.data.Word" title="koalanlp.data.Word">Word</a></p>
</dd>
<dt class="field-even">반환값</dt>
<dd class="field-even"><p>의미역 구조에서 서술된 논항 [Word]</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="koalanlp.data.RoleEdge.getDest">
<code class="sig-name descname">getDest</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#koalanlp.data.RoleEdge.getDest" title="정의 주소">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">반환값</dt>
<dd class="field-odd"><p>Edge의 종점. 의존구문분석인 경우 피지배소, 의미역인 경우 논항.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="koalanlp.data.RoleEdge.getLabel">
<code class="sig-name descname">getLabel</code><span class="sig-paren">(</span><span class="sig-paren">)</span> &#x2192; koalanlp.types.RoleType<a class="headerlink" href="#koalanlp.data.RoleEdge.getLabel" title="정의 주소">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">반환 형식</dt>
<dd class="field-odd"><p><a class="reference internal" href="#koalanlp.types.RoleType" title="koalanlp.types.RoleType">RoleType</a></p>
</dd>
<dt class="field-even">반환값</dt>
<dd class="field-even"><p>Edge가 나타내는 관계.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="koalanlp.data.RoleEdge.getModifiers">
<code class="sig-name descname">getModifiers</code><span class="sig-paren">(</span><span class="sig-paren">)</span> &#x2192; List<a class="headerlink" href="#koalanlp.data.RoleEdge.getModifiers" title="정의 주소">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">반환 형식</dt>
<dd class="field-odd"><p>List[<a class="reference internal" href="#koalanlp.data.Word" title="koalanlp.data.Word">Word</a>]</p>
</dd>
<dt class="field-even">반환값</dt>
<dd class="field-even"><p>논항의 수식어구들</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="koalanlp.data.RoleEdge.getOriginalLabel">
<code class="sig-name descname">getOriginalLabel</code><span class="sig-paren">(</span><span class="sig-paren">)</span> &#x2192; Optional[str]<a class="headerlink" href="#koalanlp.data.RoleEdge.getOriginalLabel" title="정의 주소">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">반환 형식</dt>
<dd class="field-odd"><p>str</p>
</dd>
<dt class="field-even">반환값</dt>
<dd class="field-even"><p>원본 분석기의 표지자 String 값. 기본값은 None.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="koalanlp.data.RoleEdge.getPredicate">
<code class="sig-name descname">getPredicate</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#koalanlp.data.RoleEdge.getPredicate" title="정의 주소">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">반환 형식</dt>
<dd class="field-odd"><p><a class="reference internal" href="#koalanlp.data.Word" title="koalanlp.data.Word">Word</a></p>
</dd>
<dt class="field-even">반환값</dt>
<dd class="field-even"><p>의미역 구조에서 표현하는 동사 [Word]</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="koalanlp.data.RoleEdge.getReference">
<code class="sig-name descname">getReference</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#koalanlp.data.RoleEdge.getReference" title="정의 주소">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="koalanlp.data.RoleEdge.getSrc">
<code class="sig-name descname">getSrc</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#koalanlp.data.RoleEdge.getSrc" title="정의 주소">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">반환값</dt>
<dd class="field-odd"><p>Edge의 시작점. 의존구문분석인 경우 지배소, 의미역인 경우 동사.</p>
</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="koalanlp.data.RoleEdge.label">
<code class="sig-name descname">label</code><em class="property"> = None</em><a class="headerlink" href="#koalanlp.data.RoleEdge.label" title="정의 주소">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="koalanlp.data.RoleEdge.modifiers">
<code class="sig-name descname">modifiers</code><em class="property"> = []</em><a class="headerlink" href="#koalanlp.data.RoleEdge.modifiers" title="정의 주소">¶</a></dt>
<dd><p>논항의 수식어구 목록.</p>
</dd></dl>

<dl class="attribute">
<dt id="koalanlp.data.RoleEdge.originalLabel">
<code class="sig-name descname">originalLabel</code><em class="property"> = None</em><a class="headerlink" href="#koalanlp.data.RoleEdge.originalLabel" title="정의 주소">¶</a></dt>
<dd><p>원본 분석기의 표지자 값</p>
</dd></dl>

<dl class="attribute">
<dt id="koalanlp.data.RoleEdge.predicate">
<code class="sig-name descname">predicate</code><em class="property"> = None</em><a class="headerlink" href="#koalanlp.data.RoleEdge.predicate" title="정의 주소">¶</a></dt>
<dd><p>의미역 구조의 술어</p>
</dd></dl>

<dl class="attribute">
<dt id="koalanlp.data.RoleEdge.reference">
<code class="sig-name descname">reference</code><em class="property"> = None</em><a class="headerlink" href="#koalanlp.data.RoleEdge.reference" title="정의 주소">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="koalanlp.data.RoleEdge.src">
<code class="sig-name descname">src</code><em class="property"> = None</em><a class="headerlink" href="#koalanlp.data.RoleEdge.src" title="정의 주소">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="koalanlp.data.Morpheme">
<em class="property">class </em><code class="sig-prename descclassname">koalanlp.data.</code><code class="sig-name descname">Morpheme</code><span class="sig-paren">(</span><em class="sig-param">surface: str, tag: Union[str, koalanlp.types.POS], originalTag: str = None, reference=None</em><span class="sig-paren">)</span><a class="headerlink" href="#koalanlp.data.Morpheme" title="정의 주소">¶</a></dt>
<dd><p>형태소를 저장하는 [Property] class입니다.</p>
<dl>
<dt>참고:</dt><dd><p><strong>형태소</strong> 는 의미를 가지는 요소로서는 더 이상 분석할 수 없는 가장 작은 말의 단위로 정의됩니다.</p>
<p><strong>형태소 분석</strong> 은 문장을 형태소의 단위로 나누는 작업을 의미합니다.</p>
<p>예) '문장을 형태소로 나눠봅시다'의 경우,</p>
<ul class="simple">
<li><p>문장/일반명사, -을/조사,</p></li>
<li><p>형태소/일반명사, -로/조사,</p></li>
<li><p>나누-(다)/동사, -어-/어미, 보-(다)/동사, -ㅂ시다/어미</p></li>
</ul>
<p>로 대략 나눌 수 있습니다.</p>
<p>아래를 참고해보세요.</p>
<ul class="simple">
<li><p><a class="reference internal" href="#koalanlp.proc.Tagger" title="koalanlp.proc.Tagger"><code class="xref py py-class docutils literal notranslate"><span class="pre">koalanlp.proc.Tagger</span></code></a> 형태소 분석기의 최상위 Interface</p></li>
<li><p><a class="reference internal" href="#koalanlp.types.POS" title="koalanlp.types.POS"><code class="xref py py-class docutils literal notranslate"><span class="pre">koalanlp.types.POS</span></code></a> 형태소의 분류를 담은 Enum class</p></li>
</ul>
</dd>
</dl>
<dl class="method">
<dt id="koalanlp.data.Morpheme.__eq__">
<code class="sig-name descname">__eq__</code><span class="sig-paren">(</span><em class="sig-param">other</em><span class="sig-paren">)</span><a class="headerlink" href="#koalanlp.data.Morpheme.__eq__" title="정의 주소">¶</a></dt>
<dd><p>Return self==value.</p>
</dd></dl>

<dl class="method">
<dt id="koalanlp.data.Morpheme.__hash__">
<code class="sig-name descname">__hash__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#koalanlp.data.Morpheme.__hash__" title="정의 주소">¶</a></dt>
<dd><p>Return hash(self).</p>
</dd></dl>

<dl class="method">
<dt id="koalanlp.data.Morpheme.__repr__">
<code class="sig-name descname">__repr__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#koalanlp.data.Morpheme.__repr__" title="정의 주소">¶</a></dt>
<dd><p>Return repr(self).</p>
</dd></dl>

<dl class="attribute">
<dt id="koalanlp.data.Morpheme.entities">
<code class="sig-name descname">entities</code><em class="property"> = []</em><a class="headerlink" href="#koalanlp.data.Morpheme.entities" title="정의 주소">¶</a></dt>
<dd><p>형태소를 포함하는 개체명 목록. <a class="reference internal" href="#koalanlp.data.Morpheme.getEntities" title="koalanlp.data.Morpheme.getEntities"><code class="xref py py-meth docutils literal notranslate"><span class="pre">getEntities()</span></code></a> 참고.</p>
</dd></dl>

<dl class="method">
<dt id="koalanlp.data.Morpheme.equalsWithoutTag">
<code class="sig-name descname">equalsWithoutTag</code><span class="sig-paren">(</span><em class="sig-param">other</em><span class="sig-paren">)</span><a class="headerlink" href="#koalanlp.data.Morpheme.equalsWithoutTag" title="정의 주소">¶</a></dt>
<dd><p>타 형태소 객체 [other]와 형태소의 표면형이 같은지 비교합니다.</p>
<dl class="field-list simple">
<dt class="field-odd">매개변수</dt>
<dd class="field-odd"><p><strong>other</strong> (<a class="reference internal" href="#koalanlp.data.Morpheme" title="koalanlp.data.Morpheme"><em>Morpheme</em></a>) -- 표면형을 비교할 형태소</p>
</dd>
<dt class="field-even">반환 형식</dt>
<dd class="field-even"><p>bool</p>
</dd>
<dt class="field-odd">반환값</dt>
<dd class="field-odd"><p>표면형이 같으면 True</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="koalanlp.data.Morpheme.getEntities">
<code class="sig-name descname">getEntities</code><span class="sig-paren">(</span><span class="sig-paren">)</span> &#x2192; List[koalanlp.data.Entity]<a class="headerlink" href="#koalanlp.data.Morpheme.getEntities" title="정의 주소">¶</a></dt>
<dd><p>개체명 분석을 했다면, 현재 형태소가 속한 개체명 값을 돌려줍니다.</p>
<dl>
<dt>참고:</dt><dd><p><strong>개체명 인식</strong> 은 문장에서 인물, 장소, 기관, 대상 등을 인식하는 기술입니다.</p>
<p>예) '철저한 진상 조사를 촉구하는 국제사회의 목소리가 커지고 있는 가운데, 트럼프 미국 대통령은 되레 사우디를 감싸고 나섰습니다.'에서, 다음을 인식하는 기술입니다.</p>
<ul class="simple">
<li><p>'트럼프': 인물</p></li>
<li><p>'미국' : 국가</p></li>
<li><p>'대통령' : 직위</p></li>
<li><p>'사우디' : 국가</p></li>
</ul>
<p>아래를 참고해보세요.</p>
<ul class="simple">
<li><p><a class="reference internal" href="#koalanlp.proc.EntityRecognizer" title="koalanlp.proc.EntityRecognizer"><code class="xref py py-class docutils literal notranslate"><span class="pre">koalanlp.proc.EntityRecognizer</span></code></a> 개체명 인식기 interface</p></li>
<li><p><a class="reference internal" href="#koalanlp.data.Word.getEntities" title="koalanlp.data.Word.getEntities"><code class="xref py py-meth docutils literal notranslate"><span class="pre">koalanlp.data.Word.getEntities()</span></code></a> 어절에 연관된 모든 [Entity]를 가져오는 API</p></li>
<li><p><a class="reference internal" href="#koalanlp.data.Sentence.getEntities" title="koalanlp.data.Sentence.getEntities"><code class="xref py py-meth docutils literal notranslate"><span class="pre">koalanlp.data.Sentence.getEntities()</span></code></a> 문장에 포함된 모든 [Entity]를 가져오는 API</p></li>
<li><p><a class="reference internal" href="#koalanlp.data.Entity" title="koalanlp.data.Entity"><code class="xref py py-class docutils literal notranslate"><span class="pre">koalanlp.data.Entity</span></code></a> 개체명을 저장하는 형태</p></li>
<li><p><a class="reference internal" href="#koalanlp.types.CoarseEntityType" title="koalanlp.types.CoarseEntityType"><code class="xref py py-class docutils literal notranslate"><span class="pre">koalanlp.types.CoarseEntityType</span></code></a> [Entity]의 대분류 개체명 분류구조 Enum 값</p></li>
</ul>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">반환 형식</dt>
<dd class="field-odd"><p>List[<a class="reference internal" href="#koalanlp.data.Entity" title="koalanlp.data.Entity">Entity</a>]</p>
</dd>
<dt class="field-even">반환값</dt>
<dd class="field-even"><p>[Entity]의 목록입니다. 분석 결과가 없으면 빈 리스트</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="koalanlp.data.Morpheme.getId">
<code class="sig-name descname">getId</code><span class="sig-paren">(</span><span class="sig-paren">)</span> &#x2192; int<a class="headerlink" href="#koalanlp.data.Morpheme.getId" title="정의 주소">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">반환 형식</dt>
<dd class="field-odd"><p>int</p>
</dd>
<dt class="field-even">반환값</dt>
<dd class="field-even"><p>형태소의 어절 내 위치입니다.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="koalanlp.data.Morpheme.getOriginalTag">
<code class="sig-name descname">getOriginalTag</code><span class="sig-paren">(</span><span class="sig-paren">)</span> &#x2192; Optional[str]<a class="headerlink" href="#koalanlp.data.Morpheme.getOriginalTag" title="정의 주소">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">반환 형식</dt>
<dd class="field-odd"><p>str</p>
</dd>
<dt class="field-even">반환값</dt>
<dd class="field-even"><p>원본 형태소 분석기의 품사 String (없으면 None)</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="koalanlp.data.Morpheme.getReference">
<code class="sig-name descname">getReference</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#koalanlp.data.Morpheme.getReference" title="정의 주소">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="koalanlp.data.Morpheme.getSurface">
<code class="sig-name descname">getSurface</code><span class="sig-paren">(</span><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#koalanlp.data.Morpheme.getSurface" title="정의 주소">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">반환 형식</dt>
<dd class="field-odd"><p>str</p>
</dd>
<dt class="field-even">반환값</dt>
<dd class="field-even"><p>형태소 표면형 String</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="koalanlp.data.Morpheme.getTag">
<code class="sig-name descname">getTag</code><span class="sig-paren">(</span><span class="sig-paren">)</span> &#x2192; koalanlp.types.POS<a class="headerlink" href="#koalanlp.data.Morpheme.getTag" title="정의 주소">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">반환 형식</dt>
<dd class="field-odd"><p><a class="reference internal" href="#koalanlp.types.POS" title="koalanlp.types.POS">POS</a></p>
</dd>
<dt class="field-even">반환값</dt>
<dd class="field-even"><p>세종 품사표기</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="koalanlp.data.Morpheme.getWord">
<code class="sig-name descname">getWord</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#koalanlp.data.Morpheme.getWord" title="정의 주소">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">반환 형식</dt>
<dd class="field-odd"><p><a class="reference internal" href="#koalanlp.data.Word" title="koalanlp.data.Word">Word</a></p>
</dd>
<dt class="field-even">반환값</dt>
<dd class="field-even"><p>이 형태소를 포함하는 단어를 돌려줍니다.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="koalanlp.data.Morpheme.getWordSense">
<code class="sig-name descname">getWordSense</code><span class="sig-paren">(</span><span class="sig-paren">)</span> &#x2192; Optional[int]<a class="headerlink" href="#koalanlp.data.Morpheme.getWordSense" title="정의 주소">¶</a></dt>
<dd><p>다의어 분석 결과인, 이 형태소의 사전 속 의미/어깨번호 값을 돌려줍니다.</p>
<p>다의어 분석을 한 적이 없다면 None을 돌려줍니다.</p>
<dl class="field-list simple">
<dt class="field-odd">반환 형식</dt>
<dd class="field-odd"><p>int</p>
</dd>
<dt class="field-even">반환값</dt>
<dd class="field-even"><p>의미/어깨번호 값</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="koalanlp.data.Morpheme.hasOriginalTag">
<code class="sig-name descname">hasOriginalTag</code><span class="sig-paren">(</span><em class="sig-param">partialTag: str</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#koalanlp.data.Morpheme.hasOriginalTag" title="정의 주소">¶</a></dt>
<dd><p>원본 품사 [originalTag]가 주어진 품사 표기 [partialTag] 묶음에 포함되는지 확인합니다.</p>
<p>지정된 원본 품사가 없으면 (즉, None이면) false를 반환합니다.</p>
<dl class="simple">
<dt>단축명령:</dt><dd><ul class="simple">
<li><p>체언(명사, 수사, 대명사) <a class="reference internal" href="#koalanlp.data.Morpheme.isNoun" title="koalanlp.data.Morpheme.isNoun"><code class="xref py py-meth docutils literal notranslate"><span class="pre">isNoun()</span></code></a></p></li>
<li><p>용언(동사, 형용사)는 <a class="reference internal" href="#koalanlp.data.Morpheme.isPredicate" title="koalanlp.data.Morpheme.isPredicate"><code class="xref py py-meth docutils literal notranslate"><span class="pre">isPredicate()</span></code></a></p></li>
<li><p>수식언(관형사, 부사)는 <a class="reference internal" href="#koalanlp.data.Morpheme.isModifier" title="koalanlp.data.Morpheme.isModifier"><code class="xref py py-meth docutils literal notranslate"><span class="pre">isModifier()</span></code></a></p></li>
<li><p>관계언(조사)는 <a class="reference internal" href="#koalanlp.data.Morpheme.isJosa" title="koalanlp.data.Morpheme.isJosa"><code class="xref py py-meth docutils literal notranslate"><span class="pre">isJosa()</span></code></a></p></li>
</ul>
</dd>
<dt>참고:</dt><dd><ul class="simple">
<li><p>분석불능범주(NA, NV, NF)는 체언(N) 범주에 포함되지 않습니다.</p></li>
<li><p>세종 품사표기는 <cite>POS &lt;https://koalanlp.github.io/koalanlp/api/koalanlp/kr.bydelta.koala/-p-o-s/index.html&gt;</cite> 를 참고하세요.</p></li>
<li><p>품사 표기는 <cite>비교표 &lt;https://docs.google.com/spreadsheets/d/1OGM4JDdLk6URuegFKXg1huuKWynhg_EQnZYgTmG4h0s/edit?usp=sharing&gt;</cite> 에서 확인가능합니다.</p></li>
</ul>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">매개변수</dt>
<dd class="field-odd"><p><strong>partialTag</strong> (<em>str</em>) -- 포함 여부를 확인할 상위 형태소 분류 품사표기</p>
</dd>
<dt class="field-even">반환 형식</dt>
<dd class="field-even"><p>bool</p>
</dd>
<dt class="field-odd">반환값</dt>
<dd class="field-odd"><p>포함되는 경우 True.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="koalanlp.data.Morpheme.hasTag">
<code class="sig-name descname">hasTag</code><span class="sig-paren">(</span><em class="sig-param">partialTag: str</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#koalanlp.data.Morpheme.hasTag" title="정의 주소">¶</a></dt>
<dd><p>세종 품사 [tag]가 주어진 품사 표기 [partialTag] 묶음에 포함되는지 확인합니다.</p>
<p>예) &quot;N&quot;은 체언인지 확인하고, &quot;NP&quot;는 대명사인지 확인</p>
<dl class="simple">
<dt>단축명령:</dt><dd><ul class="simple">
<li><p>체언(명사, 수사, 대명사) <a class="reference internal" href="#koalanlp.data.Morpheme.isNoun" title="koalanlp.data.Morpheme.isNoun"><code class="xref py py-meth docutils literal notranslate"><span class="pre">isNoun()</span></code></a></p></li>
<li><p>용언(동사, 형용사)는 <a class="reference internal" href="#koalanlp.data.Morpheme.isPredicate" title="koalanlp.data.Morpheme.isPredicate"><code class="xref py py-meth docutils literal notranslate"><span class="pre">isPredicate()</span></code></a></p></li>
<li><p>수식언(관형사, 부사)는 <a class="reference internal" href="#koalanlp.data.Morpheme.isModifier" title="koalanlp.data.Morpheme.isModifier"><code class="xref py py-meth docutils literal notranslate"><span class="pre">isModifier()</span></code></a></p></li>
<li><p>관계언(조사)는 <a class="reference internal" href="#koalanlp.data.Morpheme.isJosa" title="koalanlp.data.Morpheme.isJosa"><code class="xref py py-meth docutils literal notranslate"><span class="pre">isJosa()</span></code></a></p></li>
</ul>
</dd>
<dt>참고:</dt><dd><ul class="simple">
<li><p>분석불능범주(NA, NV, NF)는 체언(N) 범주에 포함되지 않습니다.</p></li>
<li><p>세종 품사표기는 <cite>POS &lt;https://koalanlp.github.io/koalanlp/api/koalanlp/kr.bydelta.koala/-p-o-s/index.html&gt;</cite> 를 참고하세요.</p></li>
<li><p>품사 표기는 <cite>비교표 &lt;https://docs.google.com/spreadsheets/d/1OGM4JDdLk6URuegFKXg1huuKWynhg_EQnZYgTmG4h0s/edit?usp=sharing&gt;</cite> 에서 확인가능합니다.</p></li>
</ul>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">매개변수</dt>
<dd class="field-odd"><p><strong>partialTag</strong> (<em>str</em>) -- 포함 여부를 확인할 상위 형태소 분류 품사표기</p>
</dd>
<dt class="field-even">반환 형식</dt>
<dd class="field-even"><p>bool</p>
</dd>
<dt class="field-odd">반환값</dt>
<dd class="field-odd"><p>포함되는 경우 True.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="koalanlp.data.Morpheme.hasTagOneOf">
<code class="sig-name descname">hasTagOneOf</code><span class="sig-paren">(</span><em class="sig-param">*tags</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#koalanlp.data.Morpheme.hasTagOneOf" title="정의 주소">¶</a></dt>
<dd><p>세종 품사 [tag]가 주어진 품사 표기들 [tags] 묶음들 중 하나에 포함되는지 확인합니다.</p>
<p>예) hasTagOneOf(&quot;N&quot;, &quot;MM&quot;)의 경우, 체언 또는 관형사인지 확인합니다.</p>
<dl class="simple">
<dt>단축명령:</dt><dd><ul class="simple">
<li><p>체언(명사, 수사, 대명사) <a class="reference internal" href="#koalanlp.data.Morpheme.isNoun" title="koalanlp.data.Morpheme.isNoun"><code class="xref py py-meth docutils literal notranslate"><span class="pre">isNoun()</span></code></a></p></li>
<li><p>용언(동사, 형용사)는 <a class="reference internal" href="#koalanlp.data.Morpheme.isPredicate" title="koalanlp.data.Morpheme.isPredicate"><code class="xref py py-meth docutils literal notranslate"><span class="pre">isPredicate()</span></code></a></p></li>
<li><p>수식언(관형사, 부사)는 <a class="reference internal" href="#koalanlp.data.Morpheme.isModifier" title="koalanlp.data.Morpheme.isModifier"><code class="xref py py-meth docutils literal notranslate"><span class="pre">isModifier()</span></code></a></p></li>
<li><p>관계언(조사)는 <a class="reference internal" href="#koalanlp.data.Morpheme.isJosa" title="koalanlp.data.Morpheme.isJosa"><code class="xref py py-meth docutils literal notranslate"><span class="pre">isJosa()</span></code></a></p></li>
</ul>
</dd>
<dt>참고:</dt><dd><ul class="simple">
<li><p>분석불능범주(NA, NV, NF)는 체언(N) 범주에 포함되지 않습니다.</p></li>
<li><p>세종 품사표기는 <cite>POS &lt;https://koalanlp.github.io/koalanlp/api/koalanlp/kr.bydelta.koala/-p-o-s/index.html&gt;</cite> 를 참고하세요.</p></li>
<li><p>품사 표기는 <cite>비교표 &lt;https://docs.google.com/spreadsheets/d/1OGM4JDdLk6URuegFKXg1huuKWynhg_EQnZYgTmG4h0s/edit?usp=sharing&gt;</cite> 에서 확인가능합니다.</p></li>
</ul>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">매개변수</dt>
<dd class="field-odd"><p><strong>tags</strong> (<em>str</em>) -- 포함 여부를 확인할 상위 형태소 분류 품사표기들 (가변인자)</p>
</dd>
<dt class="field-even">반환 형식</dt>
<dd class="field-even"><p>bool</p>
</dd>
<dt class="field-odd">반환값</dt>
<dd class="field-odd"><p>하나라도 포함되는 경우 True.</p>
</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="koalanlp.data.Morpheme.id">
<code class="sig-name descname">id</code><em class="property"> = None</em><a class="headerlink" href="#koalanlp.data.Morpheme.id" title="정의 주소">¶</a></dt>
<dd><p>형태소의 어절 내 위치</p>
</dd></dl>

<dl class="method">
<dt id="koalanlp.data.Morpheme.isJosa">
<code class="sig-name descname">isJosa</code><span class="sig-paren">(</span><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#koalanlp.data.Morpheme.isJosa" title="정의 주소">¶</a></dt>
<dd><p>관계언(조사) 형태소인지 확인합니다.</p>
<dl class="field-list simple">
<dt class="field-odd">반환 형식</dt>
<dd class="field-odd"><p>bool</p>
</dd>
<dt class="field-even">반환값</dt>
<dd class="field-even"><p>관계언이라면 true</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="koalanlp.data.Morpheme.isModifier">
<code class="sig-name descname">isModifier</code><span class="sig-paren">(</span><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#koalanlp.data.Morpheme.isModifier" title="정의 주소">¶</a></dt>
<dd><p>수식언(관형사, 부사) 형태소인지 확인합니다.</p>
<dl class="field-list simple">
<dt class="field-odd">반환 형식</dt>
<dd class="field-odd"><p>bool</p>
</dd>
<dt class="field-even">반환값</dt>
<dd class="field-even"><p>수식언이라면 true</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="koalanlp.data.Morpheme.isNoun">
<code class="sig-name descname">isNoun</code><span class="sig-paren">(</span><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#koalanlp.data.Morpheme.isNoun" title="정의 주소">¶</a></dt>
<dd><p>체언(명사, 수사, 대명사) 형태소인지 확인합니다.</p>
<dl class="field-list simple">
<dt class="field-odd">반환 형식</dt>
<dd class="field-odd"><p>bool</p>
</dd>
<dt class="field-even">반환값</dt>
<dd class="field-even"><p>체언이라면 true</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="koalanlp.data.Morpheme.isPredicate">
<code class="sig-name descname">isPredicate</code><span class="sig-paren">(</span><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#koalanlp.data.Morpheme.isPredicate" title="정의 주소">¶</a></dt>
<dd><p>용언(동사, 형용사) 형태소인지 확인합니다.</p>
<dl class="field-list simple">
<dt class="field-odd">반환 형식</dt>
<dd class="field-odd"><p>bool</p>
</dd>
<dt class="field-even">반환값</dt>
<dd class="field-even"><p>용언이라면 true</p>
</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="koalanlp.data.Morpheme.originalTag">
<code class="sig-name descname">originalTag</code><em class="property"> = None</em><a class="headerlink" href="#koalanlp.data.Morpheme.originalTag" title="정의 주소">¶</a></dt>
<dd><p>형태소의 원본분석기 품사</p>
</dd></dl>

<dl class="attribute">
<dt id="koalanlp.data.Morpheme.reference">
<code class="sig-name descname">reference</code><em class="property"> = None</em><a class="headerlink" href="#koalanlp.data.Morpheme.reference" title="정의 주소">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="koalanlp.data.Morpheme.surface">
<code class="sig-name descname">surface</code><em class="property"> = ''</em><a class="headerlink" href="#koalanlp.data.Morpheme.surface" title="정의 주소">¶</a></dt>
<dd><p>형태소 표면형</p>
</dd></dl>

<dl class="attribute">
<dt id="koalanlp.data.Morpheme.tag">
<code class="sig-name descname">tag</code><em class="property"> = None</em><a class="headerlink" href="#koalanlp.data.Morpheme.tag" title="정의 주소">¶</a></dt>
<dd><p>형태소의 세종 품사</p>
</dd></dl>

<dl class="attribute">
<dt id="koalanlp.data.Morpheme.word">
<code class="sig-name descname">word</code><em class="property"> = None</em><a class="headerlink" href="#koalanlp.data.Morpheme.word" title="정의 주소">¶</a></dt>
<dd><p>형태소의 상위 어절.</p>
</dd></dl>

<dl class="attribute">
<dt id="koalanlp.data.Morpheme.wordSense">
<code class="sig-name descname">wordSense</code><em class="property"> = None</em><a class="headerlink" href="#koalanlp.data.Morpheme.wordSense" title="정의 주소">¶</a></dt>
<dd><p>형태소의 의미 어깨번호. <a class="reference internal" href="#koalanlp.data.Morpheme.getWordSense" title="koalanlp.data.Morpheme.getWordSense"><code class="xref py py-meth docutils literal notranslate"><span class="pre">getWordSense()</span></code></a> 참고.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="koalanlp.data.Word">
<em class="property">class </em><code class="sig-prename descclassname">koalanlp.data.</code><code class="sig-name descname">Word</code><span class="sig-paren">(</span><em class="sig-param">surface</em>, <em class="sig-param">morphemes</em>, <em class="sig-param">reference=None</em><span class="sig-paren">)</span><a class="headerlink" href="#koalanlp.data.Word" title="정의 주소">¶</a></dt>
<dd><p>어절을 표현하는 [Property] class입니다.</p>
<dl class="method">
<dt id="koalanlp.data.Word.__contains__">
<code class="sig-name descname">__contains__</code><span class="sig-paren">(</span><em class="sig-param">item</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#koalanlp.data.Word.__contains__" title="정의 주소">¶</a></dt>
<dd><p>대상이 포함되는지 확인합니다.</p>
<dl class="field-list simple">
<dt class="field-odd">매개변수</dt>
<dd class="field-odd"><p><strong>item</strong> -- 포함되는지 확인할 대상</p>
</dd>
<dt class="field-even">반환 형식</dt>
<dd class="field-even"><p>bool</p>
</dd>
<dt class="field-odd">반환값</dt>
<dd class="field-odd"><p>해당 대상이 포함되면 true.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="koalanlp.data.Word.__eq__">
<code class="sig-name descname">__eq__</code><span class="sig-paren">(</span><em class="sig-param">other</em><span class="sig-paren">)</span><a class="headerlink" href="#koalanlp.data.Word.__eq__" title="정의 주소">¶</a></dt>
<dd><p>두 대상이 같은지 확인합니다.</p>
<dl class="field-list simple">
<dt class="field-odd">매개변수</dt>
<dd class="field-odd"><p><strong>other</strong> -- 이 객체와 비교할 다른 객체</p>
</dd>
<dt class="field-even">반환 형식</dt>
<dd class="field-even"><p>bool</p>
</dd>
<dt class="field-odd">반환값</dt>
<dd class="field-odd"><p>Java Reference가 같다면 true.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="koalanlp.data.Word.__getitem__">
<code class="sig-name descname">__getitem__</code><span class="sig-paren">(</span><em class="sig-param">item</em><span class="sig-paren">)</span><a class="headerlink" href="#koalanlp.data.Word.__getitem__" title="정의 주소">¶</a></dt>
<dd><p>포함된 대상을 가져옵니다.</p>
<dl class="field-list simple">
<dt class="field-odd">매개변수</dt>
<dd class="field-odd"><p><strong>item</strong> -- index의 번호 또는 slice</p>
</dd>
<dt class="field-even">반환값</dt>
<dd class="field-even"><p>지정된 위치에 있는 대상(들)</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="koalanlp.data.Word.__hash__">
<code class="sig-name descname">__hash__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#koalanlp.data.Word.__hash__" title="정의 주소">¶</a></dt>
<dd><p>해쉬 값을 계산합니다.</p>
<dl class="field-list simple">
<dt class="field-odd">반환 형식</dt>
<dd class="field-odd"><p>int</p>
</dd>
<dt class="field-even">반환값</dt>
<dd class="field-even"><p>Java Reference의 Hash code</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="koalanlp.data.Word.__iter__">
<code class="sig-name descname">__iter__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#koalanlp.data.Word.__iter__" title="정의 주소">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">반환 형식</dt>
<dd class="field-odd"><p>iter</p>
</dd>
<dt class="field-even">반환값</dt>
<dd class="field-even"><p>포함된 대상을 순회하는 iterator</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="koalanlp.data.Word.__len__">
<code class="sig-name descname">__len__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#koalanlp.data.Word.__len__" title="정의 주소">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">반환 형식</dt>
<dd class="field-odd"><p>int</p>
</dd>
<dt class="field-even">반환값</dt>
<dd class="field-even"><p>포함된 대상의 개수</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="koalanlp.data.Word.__repr__">
<code class="sig-name descname">__repr__</code><span class="sig-paren">(</span><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#koalanlp.data.Word.__repr__" title="정의 주소">¶</a></dt>
<dd><p>문자열 표현을 생성합니다.</p>
<dl class="field-list simple">
<dt class="field-odd">반환 형식</dt>
<dd class="field-odd"><p>str</p>
</dd>
<dt class="field-even">반환값</dt>
<dd class="field-even"><p>이 객체의 문자열 표현</p>
</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="koalanlp.data.Word.argumentRoles">
<code class="sig-name descname">argumentRoles</code><em class="property"> = []</em><a class="headerlink" href="#koalanlp.data.Word.argumentRoles" title="정의 주소">¶</a></dt>
<dd><p>의미역 분석을 했다면, 현재 어절이 술어로 기능하는 하위 의미역 구조의 목록. <a class="reference internal" href="#koalanlp.data.Word.getArgumentRoles" title="koalanlp.data.Word.getArgumentRoles"><code class="xref py py-meth docutils literal notranslate"><span class="pre">getArgumentRoles()</span></code></a> 참고.</p>
</dd></dl>

<dl class="method">
<dt id="koalanlp.data.Word.copy">
<code class="sig-name descname">copy</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#koalanlp.data.Word.copy" title="정의 주소">¶</a></dt>
<dd><dl class="simple">
<dt>참고:</dt><dd><p><code class="xref py py-meth docutils literal notranslate"><span class="pre">builtins.list.copy()</span></code></p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">반환값</dt>
<dd class="field-odd"><p>a shallow copied list of this</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="koalanlp.data.Word.count">
<code class="sig-name descname">count</code><span class="sig-paren">(</span><em class="sig-param">obj</em><span class="sig-paren">)</span><a class="headerlink" href="#koalanlp.data.Word.count" title="정의 주소">¶</a></dt>
<dd><dl class="simple">
<dt>참고:</dt><dd><p><code class="xref py py-meth docutils literal notranslate"><span class="pre">builtins.list.count()</span></code></p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">매개변수</dt>
<dd class="field-odd"><p><strong>obj</strong> -- 세고자 하는 객체</p>
</dd>
<dt class="field-even">반환 형식</dt>
<dd class="field-even"><p>number</p>
</dd>
<dt class="field-odd">반환값</dt>
<dd class="field-odd"><p>return number of occurrences of value</p>
</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="koalanlp.data.Word.dependentEdges">
<code class="sig-name descname">dependentEdges</code><em class="property"> = []</em><a class="headerlink" href="#koalanlp.data.Word.dependentEdges" title="정의 주소">¶</a></dt>
<dd><p>의존구문분석을 했다면, 현재 어절이 지배소인 하위 의존구문 구조의 값. <a class="reference internal" href="#koalanlp.data.Word.getDependentEdges" title="koalanlp.data.Word.getDependentEdges"><code class="xref py py-meth docutils literal notranslate"><span class="pre">getDependentEdges()</span></code></a> 참고.</p>
</dd></dl>

<dl class="attribute">
<dt id="koalanlp.data.Word.entities">
<code class="sig-name descname">entities</code><em class="property"> = []</em><a class="headerlink" href="#koalanlp.data.Word.entities" title="정의 주소">¶</a></dt>
<dd><p>개체명 분석을 했다면, 현재 어절이 속한 개체명 값. <a class="reference internal" href="#koalanlp.data.Word.getEntities" title="koalanlp.data.Word.getEntities"><code class="xref py py-meth docutils literal notranslate"><span class="pre">getEntities()</span></code></a> 참고</p>
</dd></dl>

<dl class="method">
<dt id="koalanlp.data.Word.equalsWithoutTag">
<code class="sig-name descname">equalsWithoutTag</code><span class="sig-paren">(</span><em class="sig-param">other</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#koalanlp.data.Word.equalsWithoutTag" title="정의 주소">¶</a></dt>
<dd><p>[other] 어절과 표면형이 같은지 비교합니다.
:param Word other: 표면형을 비교할 다른 어절
:rtype: bool
:return: 표면형이 같으면 true</p>
</dd></dl>

<dl class="method">
<dt id="koalanlp.data.Word.getArgumentRoles">
<code class="sig-name descname">getArgumentRoles</code><span class="sig-paren">(</span><span class="sig-paren">)</span> &#x2192; List[koalanlp.data.RoleEdge]<a class="headerlink" href="#koalanlp.data.Word.getArgumentRoles" title="정의 주소">¶</a></dt>
<dd><p>의미역 분석을 했다면, 현재 어절이 술어로 기능하는 하위 의미역 구조의 목록을 돌려줌.</p>
<dl>
<dt>참고:</dt><dd><p><strong>의미역 결정</strong> 은 문장의 구성 어절들의 역할/기능을 분석하는 방법입니다.</p>
<p>예) '나는 밥을 어제 집에서 먹었다'라는 문장에는</p>
<p>동사 '먹었다'를 중심으로</p>
<ul class="simple">
<li><p>'나는'은 동작의 주체를,</p></li>
<li><p>'밥을'은 동작의 대상을,</p></li>
<li><p>'어제'는 동작의 시점을</p></li>
<li><p>'집에서'는 동작의 장소를 나타냅니다.</p></li>
</ul>
<p>아래를 참고해보세요.</p>
<ul class="simple">
<li><p><a class="reference internal" href="#koalanlp.proc.RoleLabeler" title="koalanlp.proc.RoleLabeler"><code class="xref py py-class docutils literal notranslate"><span class="pre">koalanlp.proc.RoleLabeler</span></code></a> 의미역 분석을 수행하는 interface.</p></li>
<li><p><a class="reference internal" href="#koalanlp.data.Word.getPredicateRoles" title="koalanlp.data.Word.getPredicateRoles"><code class="xref py py-meth docutils literal notranslate"><span class="pre">koalanlp.data.Word.getPredicateRoles()</span></code></a> 어절이 논항인 [RoleEdge]의 술어를 가져오는 API</p></li>
<li><p><a class="reference internal" href="#koalanlp.data.Sentence.getRoles" title="koalanlp.data.Sentence.getRoles"><code class="xref py py-meth docutils literal notranslate"><span class="pre">koalanlp.data.Sentence.getRoles()</span></code></a> 전체 문장을 분석한 의미역 구조 [RoleEdge]를 가져오는 API</p></li>
<li><p><a class="reference internal" href="#koalanlp.data.RoleEdge" title="koalanlp.data.RoleEdge"><code class="xref py py-class docutils literal notranslate"><span class="pre">koalanlp.data.RoleEdge</span></code></a> 의미역 구조를 저장하는 형태</p></li>
<li><p><a class="reference internal" href="#koalanlp.types.RoleType" title="koalanlp.types.RoleType"><code class="xref py py-class docutils literal notranslate"><span class="pre">koalanlp.types.RoleType</span></code></a> 의미역 분류를 갖는 Enum 값</p></li>
</ul>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">반환 형식</dt>
<dd class="field-odd"><p>List[<a class="reference internal" href="#koalanlp.data.RoleEdge" title="koalanlp.data.RoleEdge">RoleEdge</a>]</p>
</dd>
<dt class="field-even">반환값</dt>
<dd class="field-even"><p>어절이 술어로 기능하는 하위 의미역 구조 [RoleEdge]의 목록. 분석 결과가 없으면 빈 리스트.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="koalanlp.data.Word.getDependentEdges">
<code class="sig-name descname">getDependentEdges</code><span class="sig-paren">(</span><span class="sig-paren">)</span> &#x2192; List[koalanlp.data.DepEdge]<a class="headerlink" href="#koalanlp.data.Word.getDependentEdges" title="정의 주소">¶</a></dt>
<dd><p>의존구문분석을 했다면, 현재 어절이 지배소인 하위 의존구문 구조의 값을 돌려줍니다.</p>
<dl>
<dt>참고:</dt><dd><p><strong>의존구조 분석</strong> 은 문장의 구성 어절들이 의존 또는 기능하는 관계를 분석하는 방법입니다.</p>
<p>예) '나는 밥을 먹었고, 영희는 짐을 쌌다'라는 문장에는</p>
<p>가장 마지막 단어인 '쌌다'가 핵심 어구가 되며,</p>
<ul class="simple">
<li><p>'먹었고'가 '쌌다'와 대등하게 연결되고</p></li>
<li><p>'나는'은 '먹었고'의 주어로 기능하며</p></li>
<li><p>'밥을'은 '먹었고'의 목적어로 기능합니다.</p></li>
<li><p>'영희는'은 '쌌다'의 주어로 기능하고,</p></li>
<li><p>'짐을'은 '쌌다'의 목적어로 기능합니다.</p></li>
</ul>
<p>아래를 참고해보세요.</p>
<ul class="simple">
<li><p><a class="reference internal" href="#koalanlp.proc.Parser" title="koalanlp.proc.Parser"><code class="xref py py-class docutils literal notranslate"><span class="pre">koalanlp.proc.Parser</span></code></a> 의존구조 분석을 수행하는 interface.</p></li>
<li><p><a class="reference internal" href="#koalanlp.data.Word.getGovernorEdge" title="koalanlp.data.Word.getGovernorEdge"><code class="xref py py-meth docutils literal notranslate"><span class="pre">koalanlp.data.Word.getGovernorEdge()</span></code></a> 어절이 지배당하는 상위 의존구조 [DepEdge]를 가져오는 API</p></li>
<li><p><a class="reference internal" href="#koalanlp.data.Sentence.getDependencies" title="koalanlp.data.Sentence.getDependencies"><code class="xref py py-meth docutils literal notranslate"><span class="pre">koalanlp.data.Sentence.getDependencies()</span></code></a> 전체 문장을 분석한 의존구조 [DepEdge]의 목록을 가져오는 API</p></li>
<li><p><a class="reference internal" href="#koalanlp.types.PhraseTag" title="koalanlp.types.PhraseTag"><code class="xref py py-meth docutils literal notranslate"><span class="pre">koalanlp.types.PhraseTag()</span></code></a> 의존구조의 형태 분류를 갖는 Enum 값 (구구조 분류와 같음)</p></li>
<li><p><a class="reference internal" href="#koalanlp.types.DependencyTag" title="koalanlp.types.DependencyTag"><code class="xref py py-meth docutils literal notranslate"><span class="pre">koalanlp.types.DependencyTag()</span></code></a> 의존구조의 기능 분류를 갖는 Enum 값</p></li>
<li><p><a class="reference internal" href="#koalanlp.data.DepEdge" title="koalanlp.data.DepEdge"><code class="xref py py-class docutils literal notranslate"><span class="pre">koalanlp.data.DepEdge</span></code></a> 의존구문구조의 저장형태</p></li>
</ul>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">반환 형식</dt>
<dd class="field-odd"><p>List[<a class="reference internal" href="#koalanlp.data.DepEdge" title="koalanlp.data.DepEdge">DepEdge</a>]</p>
</dd>
<dt class="field-even">반환값</dt>
<dd class="field-even"><p>어절이 지배하는 의존구문구조 [DepEdge]의 목록. 분석 결과가 없으면 빈 리스트.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="koalanlp.data.Word.getEntities">
<code class="sig-name descname">getEntities</code><span class="sig-paren">(</span><span class="sig-paren">)</span> &#x2192; List[koalanlp.data.Entity]<a class="headerlink" href="#koalanlp.data.Word.getEntities" title="정의 주소">¶</a></dt>
<dd><p>개체명 분석을 했다면, 현재 어절이 속한 개체명 값을 돌려줍니다.</p>
<dl>
<dt>참고:</dt><dd><p><strong>개체명 인식</strong> 은 문장에서 인물, 장소, 기관, 대상 등을 인식하는 기술입니다.</p>
<p>예) '철저한 진상 조사를 촉구하는 국제사회의 목소리가 커지고 있는 가운데, 트럼프 미국 대통령은 되레 사우디를 감싸고 나섰습니다.'에서, 다음을 인식하는 기술입니다.</p>
<ul class="simple">
<li><p>'트럼프': 인물</p></li>
<li><p>'미국' : 국가</p></li>
<li><p>'대통령' : 직위</p></li>
<li><p>'사우디' : 국가</p></li>
</ul>
<p>아래를 참고해보세요.</p>
<ul class="simple">
<li><p><a class="reference internal" href="#koalanlp.proc.EntityRecognizer" title="koalanlp.proc.EntityRecognizer"><code class="xref py py-class docutils literal notranslate"><span class="pre">koalanlp.proc.EntityRecognizer</span></code></a> 개체명 인식기 interface</p></li>
<li><p><a class="reference internal" href="#koalanlp.data.Morpheme.getEntities" title="koalanlp.data.Morpheme.getEntities"><code class="xref py py-meth docutils literal notranslate"><span class="pre">koalanlp.data.Morpheme.getEntities()</span></code></a> 형태소를 포함하는 모든 [Entity]를 가져오는 API</p></li>
<li><p><a class="reference internal" href="#koalanlp.data.Sentence.getEntities" title="koalanlp.data.Sentence.getEntities"><code class="xref py py-meth docutils literal notranslate"><span class="pre">koalanlp.data.Sentence.getEntities()</span></code></a> 문장에 포함된 모든 [Entity]를 가져오는 API</p></li>
<li><p><a class="reference internal" href="#koalanlp.data.Entity" title="koalanlp.data.Entity"><code class="xref py py-class docutils literal notranslate"><span class="pre">koalanlp.data.Entity</span></code></a> 개체명을 저장하는 형태</p></li>
<li><p><a class="reference internal" href="#koalanlp.types.CoarseEntityType" title="koalanlp.types.CoarseEntityType"><code class="xref py py-class docutils literal notranslate"><span class="pre">koalanlp.types.CoarseEntityType</span></code></a> [Entity]의 대분류 개체명 분류구조 Enum 값</p></li>
</ul>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">반환 형식</dt>
<dd class="field-odd"><p>List[<a class="reference internal" href="#koalanlp.data.Entity" title="koalanlp.data.Entity">Entity</a>]</p>
</dd>
<dt class="field-even">반환값</dt>
<dd class="field-even"><p>[Entity]의 목록입니다. 분석 결과가 없으면 빈 리스트.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="koalanlp.data.Word.getGovernorEdge">
<code class="sig-name descname">getGovernorEdge</code><span class="sig-paren">(</span><span class="sig-paren">)</span> &#x2192; koalanlp.data.DepEdge<a class="headerlink" href="#koalanlp.data.Word.getGovernorEdge" title="정의 주소">¶</a></dt>
<dd><p>의존구문분석을 했다면, 현재 어절이 의존소인 상위 의존구문 구조의 값을 돌려줍니다.</p>
<dl>
<dt>참고:</dt><dd><p><strong>의존구조 분석</strong> 은 문장의 구성 어절들이 의존 또는 기능하는 관계를 분석하는 방법입니다.</p>
<p>예) '나는 밥을 먹었고, 영희는 짐을 쌌다'라는 문장에는</p>
<p>가장 마지막 단어인 '쌌다'가 핵심 어구가 되며,</p>
<ul class="simple">
<li><p>'먹었고'가 '쌌다'와 대등하게 연결되고</p></li>
<li><p>'나는'은 '먹었고'의 주어로 기능하며</p></li>
<li><p>'밥을'은 '먹었고'의 목적어로 기능합니다.</p></li>
<li><p>'영희는'은 '쌌다'의 주어로 기능하고,</p></li>
<li><p>'짐을'은 '쌌다'의 목적어로 기능합니다.</p></li>
</ul>
<p>아래를 참고해보세요.</p>
<ul class="simple">
<li><p><a class="reference internal" href="#koalanlp.proc.Parser" title="koalanlp.proc.Parser"><code class="xref py py-class docutils literal notranslate"><span class="pre">koalanlp.proc.Parser</span></code></a> 의존구조 분석을 수행하는 interface.</p></li>
<li><p><a class="reference internal" href="#koalanlp.data.Word.getDependentEdges" title="koalanlp.data.Word.getDependentEdges"><code class="xref py py-meth docutils literal notranslate"><span class="pre">koalanlp.data.Word.getDependentEdges()</span></code></a> 어절이 직접 지배하는 하위 의존구조 [DepEdge]의 목록를 가져오는 API</p></li>
<li><p><a class="reference internal" href="#koalanlp.data.Sentence.getDependencies" title="koalanlp.data.Sentence.getDependencies"><code class="xref py py-meth docutils literal notranslate"><span class="pre">koalanlp.data.Sentence.getDependencies()</span></code></a> 전체 문장을 분석한 의존구조 [DepEdge]의 목록을 가져오는 API</p></li>
<li><p><a class="reference internal" href="#koalanlp.types.PhraseTag" title="koalanlp.types.PhraseTag"><code class="xref py py-meth docutils literal notranslate"><span class="pre">koalanlp.types.PhraseTag()</span></code></a> 의존구조의 형태 분류를 갖는 Enum 값 (구구조 분류와 같음)</p></li>
<li><p><a class="reference internal" href="#koalanlp.types.DependencyTag" title="koalanlp.types.DependencyTag"><code class="xref py py-meth docutils literal notranslate"><span class="pre">koalanlp.types.DependencyTag()</span></code></a> 의존구조의 기능 분류를 갖는 Enum 값</p></li>
<li><p><a class="reference internal" href="#koalanlp.data.DepEdge" title="koalanlp.data.DepEdge"><code class="xref py py-class docutils literal notranslate"><span class="pre">koalanlp.data.DepEdge</span></code></a> 의존구문구조의 저장형태</p></li>
</ul>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">반환 형식</dt>
<dd class="field-odd"><p>List[<a class="reference internal" href="#koalanlp.data.DepEdge" title="koalanlp.data.DepEdge">DepEdge</a>]</p>
</dd>
<dt class="field-even">반환값</dt>
<dd class="field-even"><p>어절이 지배당하는 의존구문구조 [DepEdge]. 분석 결과가 없으면 None</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="koalanlp.data.Word.getId">
<code class="sig-name descname">getId</code><span class="sig-paren">(</span><span class="sig-paren">)</span> &#x2192; int<a class="headerlink" href="#koalanlp.data.Word.getId" title="정의 주소">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">반환 형식</dt>
<dd class="field-odd"><p>int</p>
</dd>
<dt class="field-even">반환값</dt>
<dd class="field-even"><p>어절의 문장 내 위치입니다.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="koalanlp.data.Word.getPhrase">
<code class="sig-name descname">getPhrase</code><span class="sig-paren">(</span><span class="sig-paren">)</span> &#x2192; koalanlp.data.SyntaxTree<a class="headerlink" href="#koalanlp.data.Word.getPhrase" title="정의 주소">¶</a></dt>
<dd><p>구문분석을 했다면, 현재 어절이 속한 직속 상위 구구조(Phrase)를 돌려줍니다.</p>
<dl>
<dt>참고:</dt><dd><p><strong>구문구조 분석</strong> 은 문장의 구성요소들(어절, 구, 절)이 이루는 문법적 구조를 분석하는 방법입니다.</p>
<p>예) '나는 밥을 먹었고, 영희는 짐을 쌌다'라는 문장에는 2개의 절이 있습니다</p>
<ul class="simple">
<li><p>나는 밥을 먹었고</p></li>
<li><p>영희는 짐을 쌌다</p></li>
</ul>
<p>각 절은 3개의 구를 포함합니다</p>
<ul class="simple">
<li><p>나는, 밥을, 영희는, 짐을: 체언구</p></li>
<li><p>먹었고, 쌌다: 용언구</p></li>
</ul>
<p>아래를 참고해보세요.</p>
<ul class="simple">
<li><p><a class="reference internal" href="#koalanlp.proc.Parser" title="koalanlp.proc.Parser"><code class="xref py py-class docutils literal notranslate"><span class="pre">koalanlp.proc.Parser</span></code></a> 구문구조 분석을 수행하는 interface.</p></li>
<li><p><a class="reference internal" href="#koalanlp.data.Sentence.getSyntaxTree" title="koalanlp.data.Sentence.getSyntaxTree"><code class="xref py py-meth docutils literal notranslate"><span class="pre">koalanlp.data.Sentence.getSyntaxTree()</span></code></a> 전체 문장을 분석한 [SyntaxTree]를 가져오는 API</p></li>
<li><p><a class="reference internal" href="#koalanlp.data.SyntaxTree" title="koalanlp.data.SyntaxTree"><code class="xref py py-class docutils literal notranslate"><span class="pre">koalanlp.data.SyntaxTree</span></code></a> 구문구조를 저장하는 형태</p></li>
<li><p><a class="reference internal" href="#koalanlp.types.PhraseTag" title="koalanlp.types.PhraseTag"><code class="xref py py-class docutils literal notranslate"><span class="pre">koalanlp.types.PhraseTag</span></code></a> 구구조의 형태 분류를 갖는 Enum 값</p></li>
</ul>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">반환 형식</dt>
<dd class="field-odd"><p><a class="reference internal" href="#koalanlp.data.SyntaxTree" title="koalanlp.data.SyntaxTree">SyntaxTree</a></p>
</dd>
<dt class="field-even">반환값</dt>
<dd class="field-even"><p>어절의 상위 구구조 [SyntaxTree]. 분석 결과가 없으면 None</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="koalanlp.data.Word.getPredicateRoles">
<code class="sig-name descname">getPredicateRoles</code><span class="sig-paren">(</span><span class="sig-paren">)</span> &#x2192; List[koalanlp.data.RoleEdge]<a class="headerlink" href="#koalanlp.data.Word.getPredicateRoles" title="정의 주소">¶</a></dt>
<dd><p>의미역 분석을 했다면, 현재 어절이 논항인 상위 의미역 구조를 돌려줌.</p>
<dl>
<dt>참고:</dt><dd><p><strong>의미역 결정</strong> 은 문장의 구성 어절들의 역할/기능을 분석하는 방법입니다.</p>
<p>예) '나는 밥을 어제 집에서 먹었다'라는 문장에는</p>
<p>동사 '먹었다'를 중심으로</p>
<ul class="simple">
<li><p>'나는'은 동작의 주체를,</p></li>
<li><p>'밥을'은 동작의 대상을,</p></li>
<li><p>'어제'는 동작의 시점을</p></li>
<li><p>'집에서'는 동작의 장소를 나타냅니다.</p></li>
</ul>
<p>아래를 참고해보세요.</p>
<ul class="simple">
<li><p><a class="reference internal" href="#koalanlp.proc.RoleLabeler" title="koalanlp.proc.RoleLabeler"><code class="xref py py-class docutils literal notranslate"><span class="pre">koalanlp.proc.RoleLabeler</span></code></a> 의미역 분석을 수행하는 interface.</p></li>
<li><p><a class="reference internal" href="#koalanlp.data.Word.getArgumentRoles" title="koalanlp.data.Word.getArgumentRoles"><code class="xref py py-meth docutils literal notranslate"><span class="pre">koalanlp.data.Word.getArgumentRoles()</span></code></a> 어절이 술어인 논항들의 [RoleEdge] 목록을 가져오는 API</p></li>
<li><p><a class="reference internal" href="#koalanlp.data.Sentence.getRoles" title="koalanlp.data.Sentence.getRoles"><code class="xref py py-meth docutils literal notranslate"><span class="pre">koalanlp.data.Sentence.getRoles()</span></code></a> 전체 문장을 분석한 의미역 구조 [RoleEdge]를 가져오는 API</p></li>
<li><p><a class="reference internal" href="#koalanlp.data.RoleEdge" title="koalanlp.data.RoleEdge"><code class="xref py py-class docutils literal notranslate"><span class="pre">koalanlp.data.RoleEdge</span></code></a> 의미역 구조를 저장하는 형태</p></li>
<li><p><a class="reference internal" href="#koalanlp.types.RoleType" title="koalanlp.types.RoleType"><code class="xref py py-class docutils literal notranslate"><span class="pre">koalanlp.types.RoleType</span></code></a> 의미역 분류를 갖는 Enum 값</p></li>
</ul>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">반환 형식</dt>
<dd class="field-odd"><p>List[<a class="reference internal" href="#koalanlp.data.RoleEdge" title="koalanlp.data.RoleEdge">RoleEdge</a>]</p>
</dd>
<dt class="field-even">반환값</dt>
<dd class="field-even"><p>어절이 논항인 상위 의미역 구조 [RoleEdge]. 분석 결과가 없으면 빈 리스트.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="koalanlp.data.Word.getReference">
<code class="sig-name descname">getReference</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#koalanlp.data.Word.getReference" title="정의 주소">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="koalanlp.data.Word.getSurface">
<code class="sig-name descname">getSurface</code><span class="sig-paren">(</span><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#koalanlp.data.Word.getSurface" title="정의 주소">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">반환 형식</dt>
<dd class="field-odd"><p>str</p>
</dd>
<dt class="field-even">반환값</dt>
<dd class="field-even"><p>어절의 표면형 String.</p>
</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="koalanlp.data.Word.governorEdge">
<code class="sig-name descname">governorEdge</code><em class="property"> = None</em><a class="headerlink" href="#koalanlp.data.Word.governorEdge" title="정의 주소">¶</a></dt>
<dd><p>의존구문분석을 했다면, 현재 어절이 의존소인 상위 의존구문 구조의 값. <a class="reference internal" href="#koalanlp.data.Word.getGovernorEdge" title="koalanlp.data.Word.getGovernorEdge"><code class="xref py py-meth docutils literal notranslate"><span class="pre">getGovernorEdge()</span></code></a> 참고</p>
</dd></dl>

<dl class="attribute">
<dt id="koalanlp.data.Word.id">
<code class="sig-name descname">id</code><em class="property"> = None</em><a class="headerlink" href="#koalanlp.data.Word.id" title="정의 주소">¶</a></dt>
<dd><p>어절의 문장 내 위치</p>
</dd></dl>

<dl class="method">
<dt id="koalanlp.data.Word.index">
<code class="sig-name descname">index</code><span class="sig-paren">(</span><em class="sig-param">obj</em>, <em class="sig-param">start=0</em>, <em class="sig-param">stop=None</em><span class="sig-paren">)</span><a class="headerlink" href="#koalanlp.data.Word.index" title="정의 주소">¶</a></dt>
<dd><dl class="simple">
<dt>참고:</dt><dd><p><code class="xref py py-meth docutils literal notranslate"><span class="pre">builtins.list.index()</span></code></p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">매개변수</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>obj</strong> -- 찾고자 하는 객체</p></li>
<li><p><strong>start</strong> (<em>number</em>) -- 시작 지점</p></li>
<li><p><strong>stop</strong> (<em>Optional</em><em>[</em><em>number</em><em>]</em>) -- 종료 지점</p></li>
</ul>
</dd>
<dt class="field-even">반환 형식</dt>
<dd class="field-even"><p>number</p>
</dd>
<dt class="field-odd">반환값</dt>
<dd class="field-odd"><p>return first index of value. Raises ValueError if the value is not present.</p>
</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="koalanlp.data.Word.morphemes">
<code class="sig-name descname">morphemes</code><em class="property"> = []</em><a class="headerlink" href="#koalanlp.data.Word.morphemes" title="정의 주소">¶</a></dt>
<dd><p>어절 내 형태소 목록</p>
</dd></dl>

<dl class="attribute">
<dt id="koalanlp.data.Word.phrase">
<code class="sig-name descname">phrase</code><em class="property"> = None</em><a class="headerlink" href="#koalanlp.data.Word.phrase" title="정의 주소">¶</a></dt>
<dd><p>구문분석을 했다면, 현재 어절이 속한 직속 상위 구구조(Phrase). <a class="reference internal" href="#koalanlp.data.Word.getPhrase" title="koalanlp.data.Word.getPhrase"><code class="xref py py-meth docutils literal notranslate"><span class="pre">getPhrase()</span></code></a> 참고</p>
</dd></dl>

<dl class="attribute">
<dt id="koalanlp.data.Word.predicateRoles">
<code class="sig-name descname">predicateRoles</code><em class="property"> = []</em><a class="headerlink" href="#koalanlp.data.Word.predicateRoles" title="정의 주소">¶</a></dt>
<dd><p>의미역 분석을 했다면, 현재 어절이 논항인 상위 의미역 구조의 목록. <a class="reference internal" href="#koalanlp.data.Word.getPredicateRoles" title="koalanlp.data.Word.getPredicateRoles"><code class="xref py py-meth docutils literal notranslate"><span class="pre">getPredicateRoles()</span></code></a> 참고.</p>
</dd></dl>

<dl class="attribute">
<dt id="koalanlp.data.Word.reference">
<code class="sig-name descname">reference</code><em class="property"> = None</em><a class="headerlink" href="#koalanlp.data.Word.reference" title="정의 주소">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="koalanlp.data.Word.singleLineString">
<code class="sig-name descname">singleLineString</code><span class="sig-paren">(</span><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#koalanlp.data.Word.singleLineString" title="정의 주소">¶</a></dt>
<dd><p>품사분석 결과를, 1행짜리 String으로 변환합니다.</p>
<p>예) '나/NP+는/JX'</p>
<dl class="simple">
<dt>참고:</dt><dd><ul class="simple">
<li><p>세종 품사표기는 <a class="reference internal" href="#koalanlp.types.POS" title="koalanlp.types.POS"><code class="xref py py-class docutils literal notranslate"><span class="pre">koalanlp.types.POS</span></code></a> 를 참고하세요.</p></li>
</ul>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">반환값</dt>
<dd class="field-odd"><p>각 형태소별로 &quot;표면형/품사&quot; 형태로 기록하고 이를 +로 이어붙인 문자열.</p>
</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="koalanlp.data.Word.surface">
<code class="sig-name descname">surface</code><em class="property"> = ''</em><a class="headerlink" href="#koalanlp.data.Word.surface" title="정의 주소">¶</a></dt>
<dd><p>어절의 표면형</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="koalanlp.data.Sentence">
<em class="property">class </em><code class="sig-prename descclassname">koalanlp.data.</code><code class="sig-name descname">Sentence</code><span class="sig-paren">(</span><em class="sig-param">words=None</em>, <em class="sig-param">reference=None</em><span class="sig-paren">)</span><a class="headerlink" href="#koalanlp.data.Sentence" title="정의 주소">¶</a></dt>
<dd><p>문장을 표현하는 [Property] class입니다.</p>
<dl class="method">
<dt id="koalanlp.data.Sentence.__contains__">
<code class="sig-name descname">__contains__</code><span class="sig-paren">(</span><em class="sig-param">item</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#koalanlp.data.Sentence.__contains__" title="정의 주소">¶</a></dt>
<dd><p>대상이 포함되는지 확인합니다.</p>
<dl class="field-list simple">
<dt class="field-odd">매개변수</dt>
<dd class="field-odd"><p><strong>item</strong> -- 포함되는지 확인할 대상</p>
</dd>
<dt class="field-even">반환 형식</dt>
<dd class="field-even"><p>bool</p>
</dd>
<dt class="field-odd">반환값</dt>
<dd class="field-odd"><p>해당 대상이 포함되면 true.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="koalanlp.data.Sentence.__eq__">
<code class="sig-name descname">__eq__</code><span class="sig-paren">(</span><em class="sig-param">other</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#koalanlp.data.Sentence.__eq__" title="정의 주소">¶</a></dt>
<dd><p>두 대상이 같은지 확인합니다.</p>
<dl class="field-list simple">
<dt class="field-odd">매개변수</dt>
<dd class="field-odd"><p><strong>other</strong> -- 이 객체와 비교할 다른 객체</p>
</dd>
<dt class="field-even">반환 형식</dt>
<dd class="field-even"><p>bool</p>
</dd>
<dt class="field-odd">반환값</dt>
<dd class="field-odd"><p>Java Reference가 같다면 true.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="koalanlp.data.Sentence.__getitem__">
<code class="sig-name descname">__getitem__</code><span class="sig-paren">(</span><em class="sig-param">item</em><span class="sig-paren">)</span><a class="headerlink" href="#koalanlp.data.Sentence.__getitem__" title="정의 주소">¶</a></dt>
<dd><p>포함된 대상을 가져옵니다.</p>
<dl class="field-list simple">
<dt class="field-odd">매개변수</dt>
<dd class="field-odd"><p><strong>item</strong> -- index의 번호 또는 slice</p>
</dd>
<dt class="field-even">반환값</dt>
<dd class="field-even"><p>지정된 위치에 있는 대상(들)</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="koalanlp.data.Sentence.__hash__">
<code class="sig-name descname">__hash__</code><span class="sig-paren">(</span><span class="sig-paren">)</span> &#x2192; int<a class="headerlink" href="#koalanlp.data.Sentence.__hash__" title="정의 주소">¶</a></dt>
<dd><p>해쉬 값을 계산합니다.</p>
<dl class="field-list simple">
<dt class="field-odd">반환 형식</dt>
<dd class="field-odd"><p>int</p>
</dd>
<dt class="field-even">반환값</dt>
<dd class="field-even"><p>Java Reference의 Hash code</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="koalanlp.data.Sentence.__iter__">
<code class="sig-name descname">__iter__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#koalanlp.data.Sentence.__iter__" title="정의 주소">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">반환 형식</dt>
<dd class="field-odd"><p>iter</p>
</dd>
<dt class="field-even">반환값</dt>
<dd class="field-even"><p>포함된 대상을 순회하는 iterator</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="koalanlp.data.Sentence.__len__">
<code class="sig-name descname">__len__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#koalanlp.data.Sentence.__len__" title="정의 주소">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">반환 형식</dt>
<dd class="field-odd"><p>int</p>
</dd>
<dt class="field-even">반환값</dt>
<dd class="field-even"><p>포함된 대상의 개수</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="koalanlp.data.Sentence.__repr__">
<code class="sig-name descname">__repr__</code><span class="sig-paren">(</span><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#koalanlp.data.Sentence.__repr__" title="정의 주소">¶</a></dt>
<dd><p>문자열 표현을 생성합니다.</p>
<dl class="field-list simple">
<dt class="field-odd">반환 형식</dt>
<dd class="field-odd"><p>str</p>
</dd>
<dt class="field-even">반환값</dt>
<dd class="field-even"><p>이 객체의 문자열 표현</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="koalanlp.data.Sentence.copy">
<code class="sig-name descname">copy</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#koalanlp.data.Sentence.copy" title="정의 주소">¶</a></dt>
<dd><dl class="simple">
<dt>참고:</dt><dd><p><code class="xref py py-meth docutils literal notranslate"><span class="pre">builtins.list.copy()</span></code></p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">반환값</dt>
<dd class="field-odd"><p>a shallow copied list of this</p>
</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="koalanlp.data.Sentence.corefGroups">
<code class="sig-name descname">corefGroups</code><em class="property"> = []</em><a class="headerlink" href="#koalanlp.data.Sentence.corefGroups" title="정의 주소">¶</a></dt>
<dd><p>문장 내에 포함된 공통 지시어 또는 대용어들의 묶음 (분석 결과가 없으면 []). <a class="reference internal" href="#koalanlp.data.Sentence.getCorefGroups" title="koalanlp.data.Sentence.getCorefGroups"><code class="xref py py-meth docutils literal notranslate"><span class="pre">getCorefGroups()</span></code></a> 참고</p>
</dd></dl>

<dl class="method">
<dt id="koalanlp.data.Sentence.count">
<code class="sig-name descname">count</code><span class="sig-paren">(</span><em class="sig-param">obj</em><span class="sig-paren">)</span><a class="headerlink" href="#koalanlp.data.Sentence.count" title="정의 주소">¶</a></dt>
<dd><dl class="simple">
<dt>참고:</dt><dd><p><code class="xref py py-meth docutils literal notranslate"><span class="pre">builtins.list.count()</span></code></p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">매개변수</dt>
<dd class="field-odd"><p><strong>obj</strong> -- 세고자 하는 객체</p>
</dd>
<dt class="field-even">반환 형식</dt>
<dd class="field-even"><p>number</p>
</dd>
<dt class="field-odd">반환값</dt>
<dd class="field-odd"><p>return number of occurrences of value</p>
</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="koalanlp.data.Sentence.dependencies">
<code class="sig-name descname">dependencies</code><em class="property"> = []</em><a class="headerlink" href="#koalanlp.data.Sentence.dependencies" title="정의 주소">¶</a></dt>
<dd><p>문장에 포함된 모든 의존구문구조 (분석결과가 없으면 []). <a class="reference internal" href="#koalanlp.data.Sentence.getDependencies" title="koalanlp.data.Sentence.getDependencies"><code class="xref py py-meth docutils literal notranslate"><span class="pre">getDependencies()</span></code></a> 참고</p>
</dd></dl>

<dl class="attribute">
<dt id="koalanlp.data.Sentence.entities">
<code class="sig-name descname">entities</code><em class="property"> = []</em><a class="headerlink" href="#koalanlp.data.Sentence.entities" title="정의 주소">¶</a></dt>
<dd><p>문장에 포함된 모든 개체명 (분석 결과가 없으면 []). <a class="reference internal" href="#koalanlp.data.Sentence.getEntities" title="koalanlp.data.Sentence.getEntities"><code class="xref py py-meth docutils literal notranslate"><span class="pre">getEntities()</span></code></a> 참고</p>
</dd></dl>

<dl class="method">
<dt id="koalanlp.data.Sentence.fromJava">
<em class="property">static </em><code class="sig-name descname">fromJava</code><span class="sig-paren">(</span><em class="sig-param">ref</em><span class="sig-paren">)</span><a class="headerlink" href="#koalanlp.data.Sentence.fromJava" title="정의 주소">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="koalanlp.data.Sentence.getCorefGroups">
<code class="sig-name descname">getCorefGroups</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#koalanlp.data.Sentence.getCorefGroups" title="정의 주소">¶</a></dt>
<dd><p>문장 내에 포함된 공통 지시어 또는 대용어들의 묶음을 제공합니다.</p>
<dl>
<dt>참고:</dt><dd><p><strong>공지시어 해소</strong> 는 문장 내 또는 문장 간에 같은 대상을 지칭하는 어구를 찾아 묶는 분석과정입니다.</p>
<p>예) '삼성그룹의 계열사인 삼성물산은 같은 그룹의 계열사인 삼성생명과 함께'라는 문장에서</p>
<ul class="simple">
<li><p>'삼성그룹'과 '같은 그룹'을 찾아 묶는 것을 말합니다.</p></li>
</ul>
<p><strong>영형대용어 분석</strong> 은 문장에서 생략된 기능어를 찾아 문장 내 또는 문장 간에 언급되어 있는 어구와 묶는 분석과정입니다.</p>
<p>예) '나는 밥을 먹었고, 영희도 먹었다'라는 문장에서,</p>
<ul class="simple">
<li><p>'먹었다'의 목적어인 '밥을'이 생략되어 있음을 찾는 것을 말합니다.</p></li>
</ul>
<p>아래를 참고해보세요.</p>
<ul class="simple">
<li><p><code class="xref py py-class docutils literal notranslate"><span class="pre">koalanlp.proc.CorefResolver</span></code> 공지시어 해소, 대용어 분석기 interface</p></li>
<li><p><a class="reference internal" href="#koalanlp.data.Entity.getCorefGroup" title="koalanlp.data.Entity.getCorefGroup"><code class="xref py py-meth docutils literal notranslate"><span class="pre">koalanlp.data.Entity.getCorefGroup()</span></code></a> 해당 개체명이 포함된 개체명 묶음 [CoreferenceGroup]을 반환하는 API</p></li>
<li><p><a class="reference internal" href="#koalanlp.data.CoreferenceGroup" title="koalanlp.data.CoreferenceGroup"><code class="xref py py-class docutils literal notranslate"><span class="pre">koalanlp.data.CoreferenceGroup</span></code></a> 동일한 대상을 지칭하는 개체명을 묶는 API</p></li>
</ul>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">반환 형식</dt>
<dd class="field-odd"><p>List[<a class="reference internal" href="#koalanlp.data.CoreferenceGroup" title="koalanlp.data.CoreferenceGroup">CoreferenceGroup</a>]</p>
</dd>
<dt class="field-even">반환값</dt>
<dd class="field-even"><p>공통된 대상을 묶은 [CoreferenceGroup]의 목록. 없다면 빈 리스트.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="koalanlp.data.Sentence.getDependencies">
<code class="sig-name descname">getDependencies</code><span class="sig-paren">(</span><span class="sig-paren">)</span> &#x2192; List[koalanlp.data.DepEdge]<a class="headerlink" href="#koalanlp.data.Sentence.getDependencies" title="정의 주소">¶</a></dt>
<dd><p>의존구문분석을 했다면, 문장에 포함된 모든 의존구조의 목록을 돌려줍니다.</p>
<dl>
<dt>참고:</dt><dd><p><strong>의존구조 분석</strong> 은 문장의 구성 어절들이 의존 또는 기능하는 관계를 분석하는 방법입니다.</p>
<p>예) '나는 밥을 먹었고, 영희는 짐을 쌌다'라는 문장에는</p>
<p>가장 마지막 단어인 '쌌다'가 핵심 어구가 되며,</p>
<ul class="simple">
<li><p>'먹었고'가 '쌌다'와 대등하게 연결되고</p></li>
<li><p>'나는'은 '먹었고'의 주어로 기능하며</p></li>
<li><p>'밥을'은 '먹었고'의 목적어로 기능합니다.</p></li>
<li><p>'영희는'은 '쌌다'의 주어로 기능하고,</p></li>
<li><p>'짐을'은 '쌌다'의 목적어로 기능합니다.</p></li>
</ul>
<p>아래를 참고해보세요.</p>
<ul class="simple">
<li><p><a class="reference internal" href="#koalanlp.proc.Parser" title="koalanlp.proc.Parser"><code class="xref py py-class docutils literal notranslate"><span class="pre">koalanlp.proc.Parser</span></code></a> 의존구조 분석을 수행하는 interface.</p></li>
<li><p><a class="reference internal" href="#koalanlp.data.Word.getDependentEdges" title="koalanlp.data.Word.getDependentEdges"><code class="xref py py-meth docutils literal notranslate"><span class="pre">koalanlp.data.Word.getDependentEdges()</span></code></a> 어절이 직접 지배하는 하위 의존구조 [DepEdge]의 목록를 가져오는 API</p></li>
<li><p><a class="reference internal" href="#koalanlp.data.Word.getGovernorEdge" title="koalanlp.data.Word.getGovernorEdge"><code class="xref py py-meth docutils literal notranslate"><span class="pre">koalanlp.data.Word.getGovernorEdge()</span></code></a> 어절이 지배당하는 상위 의존구조 [DepEdge]를 가져오는 API</p></li>
<li><p><a class="reference internal" href="#koalanlp.types.PhraseTag" title="koalanlp.types.PhraseTag"><code class="xref py py-meth docutils literal notranslate"><span class="pre">koalanlp.types.PhraseTag()</span></code></a> 의존구조의 형태 분류를 갖는 Enum 값 (구구조 분류와 같음)</p></li>
<li><p><a class="reference internal" href="#koalanlp.types.DependencyTag" title="koalanlp.types.DependencyTag"><code class="xref py py-meth docutils literal notranslate"><span class="pre">koalanlp.types.DependencyTag()</span></code></a> 의존구조의 기능 분류를 갖는 Enum 값</p></li>
<li><p><a class="reference internal" href="#koalanlp.data.DepEdge" title="koalanlp.data.DepEdge"><code class="xref py py-class docutils literal notranslate"><span class="pre">koalanlp.data.DepEdge</span></code></a> 의존구문구조의 저장형태</p></li>
</ul>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">반환 형식</dt>
<dd class="field-odd"><p>List[<a class="reference internal" href="#koalanlp.data.DepEdge" title="koalanlp.data.DepEdge">DepEdge</a>]</p>
</dd>
<dt class="field-even">반환값</dt>
<dd class="field-even"><p>문장 내 모든 의존구문구조 [DepEdge]의 목록. 분석 결과가 없으면 빈 리스트.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="koalanlp.data.Sentence.getEntities">
<code class="sig-name descname">getEntities</code><span class="sig-paren">(</span><span class="sig-paren">)</span> &#x2192; List[koalanlp.data.Entity]<a class="headerlink" href="#koalanlp.data.Sentence.getEntities" title="정의 주소">¶</a></dt>
<dd><p>개체명 분석을 했다면, 문장의 모든 개체명 목록을 돌려줍니다.</p>
<dl>
<dt>참고:</dt><dd><p><strong>개체명 인식</strong> 은 문장에서 인물, 장소, 기관, 대상 등을 인식하는 기술입니다.</p>
<p>예) '철저한 진상 조사를 촉구하는 국제사회의 목소리가 커지고 있는 가운데, 트럼프 미국 대통령은 되레 사우디를 감싸고 나섰습니다.'에서, 다음을 인식하는 기술입니다.</p>
<ul class="simple">
<li><p>'트럼프': 인물</p></li>
<li><p>'미국' : 국가</p></li>
<li><p>'대통령' : 직위</p></li>
<li><p>'사우디' : 국가</p></li>
</ul>
<p>아래를 참고해보세요.</p>
<ul class="simple">
<li><p><a class="reference internal" href="#koalanlp.proc.EntityRecognizer" title="koalanlp.proc.EntityRecognizer"><code class="xref py py-class docutils literal notranslate"><span class="pre">koalanlp.proc.EntityRecognizer</span></code></a> 개체명 인식기 interface</p></li>
<li><p><a class="reference internal" href="#koalanlp.data.Morpheme.getEntities" title="koalanlp.data.Morpheme.getEntities"><code class="xref py py-meth docutils literal notranslate"><span class="pre">koalanlp.data.Morpheme.getEntities()</span></code></a> 형태소를 포함하는 모든 [Entity]를 가져오는 API</p></li>
<li><p><a class="reference internal" href="#koalanlp.data.Word.getEntities" title="koalanlp.data.Word.getEntities"><code class="xref py py-meth docutils literal notranslate"><span class="pre">koalanlp.data.Word.getEntities()</span></code></a> 해당 어절을 포함하는 [Entity]를 가져오는 API</p></li>
<li><p><a class="reference internal" href="#koalanlp.data.Entity" title="koalanlp.data.Entity"><code class="xref py py-class docutils literal notranslate"><span class="pre">koalanlp.data.Entity</span></code></a> 개체명을 저장하는 형태</p></li>
<li><p><a class="reference internal" href="#koalanlp.types.CoarseEntityType" title="koalanlp.types.CoarseEntityType"><code class="xref py py-class docutils literal notranslate"><span class="pre">koalanlp.types.CoarseEntityType</span></code></a> [Entity]의 대분류 개체명 분류구조 Enum 값</p></li>
</ul>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">반환 형식</dt>
<dd class="field-odd"><p>List[<a class="reference internal" href="#koalanlp.data.Entity" title="koalanlp.data.Entity">Entity</a>]</p>
</dd>
<dt class="field-even">반환값</dt>
<dd class="field-even"><p>문장에 포함된 모든 [Entity]의 목록입니다.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="koalanlp.data.Sentence.getModifiers">
<code class="sig-name descname">getModifiers</code><span class="sig-paren">(</span><span class="sig-paren">)</span> &#x2192; List[koalanlp.data.Word]<a class="headerlink" href="#koalanlp.data.Sentence.getModifiers" title="정의 주소">¶</a></dt>
<dd><p>수식언(관형사, 부사) 및 수식언 성격의 어휘를 포함하는 어절들을 가져옵니다.</p>
<ul class="simple">
<li><p>포함: 수식언, 관형형 전성어미 [POS.ETM], 형용사/부사 파생 접미사 [POS.XSA], [POS.XSM]</p></li>
<li><p>제외: 명사형 전성어미 [POS.ETN], 명사/동사 파생 접미사 [POS.XSN], [POS.XSV]</p></li>
<li><p>가장 마지막에 적용되는 어미/접미사를 기준으로 판정함</p></li>
</ul>
<dl>
<dt>참고:</dt><dd><p><strong>전성어미</strong> 는 용언 따위에 붙어 다른 품사의 기능을 수행하도록 변경하는 어미입니다.
예) '멋지게 살다'를 '멋지게 삶'으로 바꾸는 명사형 전성어미 '-ㅁ'이 있습니다. 원 기능은 동사이므로 부사의 수식을 받고 있습니다.</p>
<p><strong>파생접미사</strong> 는 용언의 어근이나 단어 따위에 붙어서 명사로 파생되도록 하는 접미사입니다.
예) 역시 '살다'를 '삶'으로 바꾸는 명사파생 접미사 '-ㅁ'이 있습니다. 이 경우 명사이므로 '멋진 삶'과 같이 형용사의 수식을 받습니다.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">반환 형식</dt>
<dd class="field-odd"><p>List[<a class="reference internal" href="#koalanlp.data.Word" title="koalanlp.data.Word">Word</a>]</p>
</dd>
<dt class="field-even">반환값</dt>
<dd class="field-even"><p>수식언 또는 수식언 성격의 어휘를 포함하는 어절의 목록</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="koalanlp.data.Sentence.getNouns">
<code class="sig-name descname">getNouns</code><span class="sig-paren">(</span><span class="sig-paren">)</span> &#x2192; List[koalanlp.data.Word]<a class="headerlink" href="#koalanlp.data.Sentence.getNouns" title="정의 주소">¶</a></dt>
<dd><p>체언(명사, 수사, 대명사) 및 체언 성격의 어휘를 포함하는 어절들을 가져옵니다.</p>
<ul class="simple">
<li><p>포함: 체언, 명사형 전성어미 [POS.ETN], 명사 파생 접미사 [POS.XSN]</p></li>
<li><p>제외: 관형형 전성어미 [POS.ETM], 동사/형용사/부사 파생 접미사 [POS.XSV], [POS.XSA], [POS.XSM]</p></li>
<li><p>가장 마지막에 적용되는 어미/접미사를 기준으로 판정함</p></li>
</ul>
<dl>
<dt>참고:</dt><dd><p><strong>전성어미</strong> 는 용언 따위에 붙어 다른 품사의 기능을 수행하도록 변경하는 어미입니다.
예) '멋지게 살다'를 '멋지게 삶'으로 바꾸는 명사형 전성어미 '-ㅁ'이 있습니다. 원 기능은 동사이므로 부사의 수식을 받고 있습니다.</p>
<p><strong>파생접미사</strong> 는 용언의 어근이나 단어 따위에 붙어서 명사로 파생되도록 하는 접미사입니다.
예) 역시 '살다'를 '삶'으로 바꾸는 명사파생 접미사 '-ㅁ'이 있습니다. 이 경우 명사이므로 '멋진 삶'과 같이 형용사의 수식을 받습니다.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">반환 형식</dt>
<dd class="field-odd"><p>List[<a class="reference internal" href="#koalanlp.data.Word" title="koalanlp.data.Word">Word</a>]</p>
</dd>
<dt class="field-even">반환값</dt>
<dd class="field-even"><p>체언 또는 체언 성격의 어휘를 포함하는 어절의 목록</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="koalanlp.data.Sentence.getReference">
<code class="sig-name descname">getReference</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#koalanlp.data.Sentence.getReference" title="정의 주소">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="koalanlp.data.Sentence.getRoles">
<code class="sig-name descname">getRoles</code><span class="sig-paren">(</span><span class="sig-paren">)</span> &#x2192; List[koalanlp.data.RoleEdge]<a class="headerlink" href="#koalanlp.data.Sentence.getRoles" title="정의 주소">¶</a></dt>
<dd><p>의미역 분석을 했다면, 문장에 포함된 의미역 구조의 목록을 돌려줌.</p>
<dl>
<dt>참고:</dt><dd><p><strong>의미역 결정</strong> 은 문장의 구성 어절들의 역할/기능을 분석하는 방법입니다.</p>
<p>예) '나는 밥을 어제 집에서 먹었다'라는 문장에는</p>
<p>동사 '먹었다'를 중심으로</p>
<ul class="simple">
<li><p>'나는'은 동작의 주체를,</p></li>
<li><p>'밥을'은 동작의 대상을,</p></li>
<li><p>'어제'는 동작의 시점을</p></li>
<li><p>'집에서'는 동작의 장소를 나타냅니다.</p></li>
</ul>
<p>아래를 참고해보세요.</p>
<ul class="simple">
<li><p><a class="reference internal" href="#koalanlp.proc.RoleLabeler" title="koalanlp.proc.RoleLabeler"><code class="xref py py-class docutils literal notranslate"><span class="pre">koalanlp.proc.RoleLabeler</span></code></a> 의미역 분석을 수행하는 interface.</p></li>
<li><p><a class="reference internal" href="#koalanlp.data.Word.getPredicateRoles" title="koalanlp.data.Word.getPredicateRoles"><code class="xref py py-meth docutils literal notranslate"><span class="pre">koalanlp.data.Word.getPredicateRoles()</span></code></a> 어절이 논항인 [RoleEdge]의 술어를 가져오는 API</p></li>
<li><p><a class="reference internal" href="#koalanlp.data.Word.getArgumentRoles" title="koalanlp.data.Word.getArgumentRoles"><code class="xref py py-meth docutils literal notranslate"><span class="pre">koalanlp.data.Word.getArgumentRoles()</span></code></a> 어절이 술어인 [RoleEdge]의 논항들을 가져오는 API</p></li>
<li><p><a class="reference internal" href="#koalanlp.data.RoleEdge" title="koalanlp.data.RoleEdge"><code class="xref py py-class docutils literal notranslate"><span class="pre">koalanlp.data.RoleEdge</span></code></a> 의미역 구조를 저장하는 형태</p></li>
<li><p><a class="reference internal" href="#koalanlp.types.RoleType" title="koalanlp.types.RoleType"><code class="xref py py-class docutils literal notranslate"><span class="pre">koalanlp.types.RoleType</span></code></a> 의미역 분류를 갖는 Enum 값</p></li>
</ul>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">반환 형식</dt>
<dd class="field-odd"><p>List[<a class="reference internal" href="#koalanlp.data.RoleEdge" title="koalanlp.data.RoleEdge">RoleEdge</a>]</p>
</dd>
<dt class="field-even">반환값</dt>
<dd class="field-even"><p>문장 속의 모든 의미역 구조 [RoleEdge]의 목록. 분석 결과가 없으면 빈 리스트.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="koalanlp.data.Sentence.getSyntaxTree">
<code class="sig-name descname">getSyntaxTree</code><span class="sig-paren">(</span><span class="sig-paren">)</span> &#x2192; koalanlp.data.SyntaxTree<a class="headerlink" href="#koalanlp.data.Sentence.getSyntaxTree" title="정의 주소">¶</a></dt>
<dd><p>구문분석을 했다면, 최상위 구구조(Phrase)를 돌려줍니다.</p>
<dl>
<dt>참고:</dt><dd><p><strong>구문구조 분석</strong> 은 문장의 구성요소들(어절, 구, 절)이 이루는 문법적 구조를 분석하는 방법입니다.</p>
<p>예) '나는 밥을 먹었고, 영희는 짐을 쌌다'라는 문장에는 2개의 절이 있습니다</p>
<ul class="simple">
<li><p>나는 밥을 먹었고</p></li>
<li><p>영희는 짐을 쌌다</p></li>
</ul>
<p>각 절은 3개의 구를 포함합니다</p>
<ul class="simple">
<li><p>나는, 밥을, 영희는, 짐을: 체언구</p></li>
<li><p>먹었고, 쌌다: 용언구</p></li>
</ul>
<p>아래를 참고해보세요.</p>
<ul class="simple">
<li><p><a class="reference internal" href="#koalanlp.proc.Parser" title="koalanlp.proc.Parser"><code class="xref py py-class docutils literal notranslate"><span class="pre">koalanlp.proc.Parser</span></code></a> 구문구조 분석을 수행하는 interface.</p></li>
<li><p><a class="reference internal" href="#koalanlp.data.Word.getPhrase" title="koalanlp.data.Word.getPhrase"><code class="xref py py-meth docutils literal notranslate"><span class="pre">koalanlp.data.Word.getPhrase()</span></code></a> 어절의 직속 상위 [SyntaxTree]를 가져오는 API</p></li>
<li><p><a class="reference internal" href="#koalanlp.data.SyntaxTree" title="koalanlp.data.SyntaxTree"><code class="xref py py-class docutils literal notranslate"><span class="pre">koalanlp.data.SyntaxTree</span></code></a> 구문구조를 저장하는 형태</p></li>
<li><p><a class="reference internal" href="#koalanlp.types.PhraseTag" title="koalanlp.types.PhraseTag"><code class="xref py py-class docutils literal notranslate"><span class="pre">koalanlp.types.PhraseTag</span></code></a> 구구조의 형태 분류를 갖는 Enum 값</p></li>
</ul>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">반환 형식</dt>
<dd class="field-odd"><p><a class="reference internal" href="#koalanlp.data.SyntaxTree" title="koalanlp.data.SyntaxTree">SyntaxTree</a></p>
</dd>
<dt class="field-even">반환값</dt>
<dd class="field-even"><p>최상위 구구조 [SyntaxTree]. 분석 결과가 없으면 None.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="koalanlp.data.Sentence.getVerbs">
<code class="sig-name descname">getVerbs</code><span class="sig-paren">(</span><span class="sig-paren">)</span> &#x2192; List[koalanlp.data.Word]<a class="headerlink" href="#koalanlp.data.Sentence.getVerbs" title="정의 주소">¶</a></dt>
<dd><p>용언(동사, 형용사) 및 용언 성격의 어휘를 포함하는 어절들을 가져옵니다.</p>
<ul class="simple">
<li><p>포함: 용언, 동사 파생 접미사 [POS.XSV]</p></li>
<li><p>제외: 명사형/관형형 전성어미 [POS.ETN], [POS.ETM], 명사/형용사/부사 파생 접미사 [POS.XSN], [POS.XSA], [POS.XSM]</p></li>
<li><p>가장 마지막에 적용되는 어미/접미사를 기준으로 판정함</p></li>
</ul>
<dl>
<dt>참고:</dt><dd><p><strong>전성어미</strong> 는 용언 따위에 붙어 다른 품사의 기능을 수행하도록 변경하는 어미입니다.
예) '멋지게 살다'를 '멋지게 삶'으로 바꾸는 명사형 전성어미 '-ㅁ'이 있습니다. 원 기능은 동사이므로 부사의 수식을 받고 있습니다.</p>
<p><strong>파생접미사</strong> 는 용언의 어근이나 단어 따위에 붙어서 명사로 파생되도록 하는 접미사입니다.
예) 역시 '살다'를 '삶'으로 바꾸는 명사파생 접미사 '-ㅁ'이 있습니다. 이 경우 명사이므로 '멋진 삶'과 같이 형용사의 수식을 받습니다.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">반환 형식</dt>
<dd class="field-odd"><p>List[<a class="reference internal" href="#koalanlp.data.Word" title="koalanlp.data.Word">Word</a>]</p>
</dd>
<dt class="field-even">반환값</dt>
<dd class="field-even"><p>용언 또는 용언 성격의 어휘를 포함하는 어절의 목록</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="koalanlp.data.Sentence.index">
<code class="sig-name descname">index</code><span class="sig-paren">(</span><em class="sig-param">obj</em>, <em class="sig-param">start=0</em>, <em class="sig-param">stop=None</em><span class="sig-paren">)</span><a class="headerlink" href="#koalanlp.data.Sentence.index" title="정의 주소">¶</a></dt>
<dd><dl class="simple">
<dt>참고:</dt><dd><p><code class="xref py py-meth docutils literal notranslate"><span class="pre">builtins.list.index()</span></code></p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">매개변수</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>obj</strong> -- 찾고자 하는 객체</p></li>
<li><p><strong>start</strong> (<em>number</em>) -- 시작 지점</p></li>
<li><p><strong>stop</strong> (<em>Optional</em><em>[</em><em>number</em><em>]</em>) -- 종료 지점</p></li>
</ul>
</dd>
<dt class="field-even">반환 형식</dt>
<dd class="field-even"><p>number</p>
</dd>
<dt class="field-odd">반환값</dt>
<dd class="field-odd"><p>return first index of value. Raises ValueError if the value is not present.</p>
</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="koalanlp.data.Sentence.reference">
<code class="sig-name descname">reference</code><em class="property"> = None</em><a class="headerlink" href="#koalanlp.data.Sentence.reference" title="정의 주소">¶</a></dt>
<dd><p>Java 문장 타입</p>
</dd></dl>

<dl class="attribute">
<dt id="koalanlp.data.Sentence.roles">
<code class="sig-name descname">roles</code><em class="property"> = []</em><a class="headerlink" href="#koalanlp.data.Sentence.roles" title="정의 주소">¶</a></dt>
<dd><p>문장에 포함된 모든 의미역 구조 (분석 결과가 없으면 []). <a class="reference internal" href="#koalanlp.data.Sentence.getRoles" title="koalanlp.data.Sentence.getRoles"><code class="xref py py-meth docutils literal notranslate"><span class="pre">getRoles()</span></code></a> 참고</p>
</dd></dl>

<dl class="method">
<dt id="koalanlp.data.Sentence.singleLineString">
<code class="sig-name descname">singleLineString</code><span class="sig-paren">(</span><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#koalanlp.data.Sentence.singleLineString" title="정의 주소">¶</a></dt>
<dd><p>품사분석 결과를, 1행짜리 String으로 변환합니다.</p>
<dl class="field-list simple">
<dt class="field-odd">반환 형식</dt>
<dd class="field-odd"><p>str</p>
</dd>
<dt class="field-even">반환값</dt>
<dd class="field-even"><p>품사분석 결과를 담은 1행짜리 String.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="koalanlp.data.Sentence.surfaceString">
<code class="sig-name descname">surfaceString</code><span class="sig-paren">(</span><em class="sig-param">delimiter: str = ' '</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#koalanlp.data.Sentence.surfaceString" title="정의 주소">¶</a></dt>
<dd><p>어절의 표면형을 이어붙이되, 지정된 [delimiter]로 띄어쓰기 된 문장을 반환합니다.</p>
<dl class="field-list simple">
<dt class="field-odd">매개변수</dt>
<dd class="field-odd"><p><strong>delimiter</strong> (<em>str</em>) -- 어절 사이의 띄어쓰기 방식. 기본값 = 공백(&quot; &quot;)</p>
</dd>
<dt class="field-even">반환값</dt>
<dd class="field-even"><p>띄어쓰기 된 문장입니다.</p>
</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="koalanlp.data.Sentence.syntaxTree">
<code class="sig-name descname">syntaxTree</code><em class="property"> = None</em><a class="headerlink" href="#koalanlp.data.Sentence.syntaxTree" title="정의 주소">¶</a></dt>
<dd><p>문장의 최상위 구구조 (분석결과가 없으면 None) <a class="reference internal" href="#koalanlp.data.Sentence.getSyntaxTree" title="koalanlp.data.Sentence.getSyntaxTree"><code class="xref py py-meth docutils literal notranslate"><span class="pre">getSyntaxTree()</span></code></a> 참고.</p>
</dd></dl>

<dl class="attribute">
<dt id="koalanlp.data.Sentence.words">
<code class="sig-name descname">words</code><em class="property"> = []</em><a class="headerlink" href="#koalanlp.data.Sentence.words" title="정의 주소">¶</a></dt>
<dd><p>문장내 어절의 목록</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-koalanlp.proc">
<span id="id3"></span><h2>사전 및 분석기<a class="headerlink" href="#module-koalanlp.proc" title="제목 주소">¶</a></h2>
<dl class="class">
<dt id="koalanlp.proc.SentenceSplitter">
<em class="property">class </em><code class="sig-prename descclassname">koalanlp.proc.</code><code class="sig-name descname">SentenceSplitter</code><span class="sig-paren">(</span><em class="sig-param">api: str</em><span class="sig-paren">)</span><a class="headerlink" href="#koalanlp.proc.SentenceSplitter" title="정의 주소">¶</a></dt>
<dd><p>기반 클래스: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>문장분리기를 생성합니다.</p>
<dl class="field-list simple">
<dt class="field-odd">매개변수</dt>
<dd class="field-odd"><p><strong>api</strong> (<em>str</em>) -- 문장분리기 API 패키지.</p>
</dd>
</dl>
<dl class="method">
<dt id="koalanlp.proc.SentenceSplitter.sentences">
<code class="sig-name descname">sentences</code><span class="sig-paren">(</span><em class="sig-param">*text</em><span class="sig-paren">)</span> &#x2192; List[str]<a class="headerlink" href="#koalanlp.proc.SentenceSplitter.sentences" title="정의 주소">¶</a></dt>
<dd><p>문단(들)을 문장으로 분리합니다.</p>
<dl class="field-list simple">
<dt class="field-odd">매개변수</dt>
<dd class="field-odd"><p><strong>text</strong> (<em>Union</em><em>[</em><em>str</em><em>,</em><em>List</em><em>[</em><em>str</em><em>]</em><em>]</em>) -- 분석할 문단(들). 각 인자는 텍스트와 string 리스트 혼용 가능. (가변인자)</p>
</dd>
<dt class="field-even">반환 형식</dt>
<dd class="field-even"><p>List[str]</p>
</dd>
<dt class="field-odd">반환값</dt>
<dd class="field-odd"><p>분리한 문장들. (flattened list)</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="koalanlp.proc.SentenceSplitter.sentencesTagged">
<em class="property">static </em><code class="sig-name descname">sentencesTagged</code><span class="sig-paren">(</span><em class="sig-param">*text</em><span class="sig-paren">)</span> &#x2192; List[koalanlp.data.Sentence]<a class="headerlink" href="#koalanlp.proc.SentenceSplitter.sentencesTagged" title="정의 주소">¶</a></dt>
<dd><p>KoalaNLP가 구현한 문장분리기를 사용하여, 문단을 문장으로 분리합니다.</p>
<dl class="field-list simple">
<dt class="field-odd">매개변수</dt>
<dd class="field-odd"><p><strong>text</strong> (<em>Union</em><em>[</em><em>List</em><em>[</em><a class="reference internal" href="#koalanlp.data.Word" title="koalanlp.data.Word"><em>Word</em></a><em>]</em><em>,</em><a class="reference internal" href="#koalanlp.data.Sentence" title="koalanlp.data.Sentence"><em>Sentence</em></a><em>]</em>) -- 분석할 문단(들). 각 인자는 품사표기가 되어있는 Word의 list 또는 Sentence 혼용 가능. (가변인자)</p>
</dd>
<dt class="field-even">반환 형식</dt>
<dd class="field-even"><p>List[<a class="reference internal" href="#koalanlp.data.Sentence" title="koalanlp.data.Sentence">Sentence</a>]</p>
</dd>
<dt class="field-odd">반환값</dt>
<dd class="field-odd"><p>분리된 문장들. (flattened list)</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="koalanlp.proc.Tagger">
<em class="property">class </em><code class="sig-prename descclassname">koalanlp.proc.</code><code class="sig-name descname">Tagger</code><span class="sig-paren">(</span><em class="sig-param">api: str</em>, <em class="sig-param">apiKey: str = ''</em>, <em class="sig-param">useLightTagger: bool = False</em><span class="sig-paren">)</span><a class="headerlink" href="#koalanlp.proc.Tagger" title="정의 주소">¶</a></dt>
<dd><p>기반 클래스: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>품사분석기를 초기화합니다.</p>
<dl class="field-list simple">
<dt class="field-odd">매개변수</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>api</strong> (<em>str</em>) -- 사용할 품사분석기의 유형.</p></li>
<li><p><strong>apiKey</strong> (<em>str</em>) -- ETRI 분석기의 경우, ETRI에서 발급받은 API Key</p></li>
<li><p><strong>useLightTagger</strong> (<em>bool</em>) -- 코모란(KMR) 분석기의 경우, 경량 분석기를 사용할 것인지의 여부. (기본값 False)</p></li>
</ul>
</dd>
</dl>
<dl class="method">
<dt id="koalanlp.proc.Tagger.tag">
<code class="sig-name descname">tag</code><span class="sig-paren">(</span><em class="sig-param">*text</em><span class="sig-paren">)</span> &#x2192; List[koalanlp.data.Sentence]<a class="headerlink" href="#koalanlp.proc.Tagger.tag" title="정의 주소">¶</a></dt>
<dd><p>문단(들)을 품사분석합니다.</p>
<dl class="field-list simple">
<dt class="field-odd">매개변수</dt>
<dd class="field-odd"><p><strong>text</strong> (<em>Union</em><em>[</em><em>str</em><em>,</em><em>List</em><em>[</em><em>str</em><em>]</em><em>]</em>) -- 분석할 문단들. 텍스트와 string 리스트 혼용 가능. (가변인자)</p>
</dd>
<dt class="field-even">반환 형식</dt>
<dd class="field-even"><p>List[<a class="reference internal" href="#koalanlp.data.Sentence" title="koalanlp.data.Sentence">Sentence</a>]</p>
</dd>
<dt class="field-odd">반환값</dt>
<dd class="field-odd"><p>분석된 결과. (flattened list)</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="koalanlp.proc.Tagger.tagSentence">
<code class="sig-name descname">tagSentence</code><span class="sig-paren">(</span><em class="sig-param">*text</em><span class="sig-paren">)</span> &#x2192; List[koalanlp.data.Sentence]<a class="headerlink" href="#koalanlp.proc.Tagger.tagSentence" title="정의 주소">¶</a></dt>
<dd><p>문장을 품사분석합니다. (인자 하나를 문장 하나로 간주합니다)</p>
<dl class="field-list simple">
<dt class="field-odd">매개변수</dt>
<dd class="field-odd"><p><strong>text</strong> (<em>Union</em><em>[</em><em>str</em><em>]</em>) -- 분석할 문장들. (가변인자)</p>
</dd>
<dt class="field-even">반환 형식</dt>
<dd class="field-even"><p>List[<a class="reference internal" href="#koalanlp.data.Sentence" title="koalanlp.data.Sentence">Sentence</a>]</p>
</dd>
<dt class="field-odd">반환값</dt>
<dd class="field-odd"><p>분석된 결과.</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="koalanlp.proc.Parser">
<em class="property">class </em><code class="sig-prename descclassname">koalanlp.proc.</code><code class="sig-name descname">Parser</code><span class="sig-paren">(</span><em class="sig-param">api: str</em>, <em class="sig-param">apiKey: str = ''</em><span class="sig-paren">)</span><a class="headerlink" href="#koalanlp.proc.Parser" title="정의 주소">¶</a></dt>
<dd><p>기반 클래스: <code class="xref py py-class docutils literal notranslate"><span class="pre">koalanlp.proc.__CanAnalyzeProperty</span></code></p>
<p>구문구조/의존구조분석기를 초기화합니다.</p>
<dl class="field-list simple">
<dt class="field-odd">매개변수</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>api</strong> (<em>str</em>) -- 사용할 분석기의 유형.</p></li>
<li><p><strong>apiKey</strong> (<em>str</em>) -- ETRI 분석기의 경우, ETRI에서 발급받은 API Key</p></li>
</ul>
</dd>
</dl>
<dl class="method">
<dt id="koalanlp.proc.Parser.analyze">
<code class="sig-name descname">analyze</code><span class="sig-paren">(</span><em class="sig-param">*text</em><span class="sig-paren">)</span> &#x2192; List[koalanlp.data.Sentence]<a class="headerlink" href="#koalanlp.proc.Parser.analyze" title="정의 주소">¶</a></dt>
<dd><p>문단(들)을 분석합니다.</p>
<dl class="field-list simple">
<dt class="field-odd">매개변수</dt>
<dd class="field-odd"><p><strong>text</strong> (<em>Union</em><em>[</em><em>str</em><em>,</em><a class="reference internal" href="#koalanlp.data.Sentence" title="koalanlp.data.Sentence"><em>Sentence</em></a><em>,</em><em>List</em><em>[</em><em>str</em><em>]</em><em>,</em><em>List</em><em>[</em><a class="reference internal" href="#koalanlp.data.Sentence" title="koalanlp.data.Sentence"><em>Sentence</em></a><em>]</em><em>]</em>) -- 분석할 문단(들).
각 인자는 텍스트(str), 문장 객체(Sentence), 텍스트의 리스트, 문장 객체의 리스트 혼용 가능 (가변인자)</p>
</dd>
<dt class="field-even">반환 형식</dt>
<dd class="field-even"><p>List[<a class="reference internal" href="#koalanlp.data.Sentence" title="koalanlp.data.Sentence">Sentence</a>]</p>
</dd>
<dt class="field-odd">반환값</dt>
<dd class="field-odd"><p>분석된 결과들. (flattened list)</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="koalanlp.proc.EntityRecognizer">
<em class="property">class </em><code class="sig-prename descclassname">koalanlp.proc.</code><code class="sig-name descname">EntityRecognizer</code><span class="sig-paren">(</span><em class="sig-param">api: str</em>, <em class="sig-param">apiKey: str = ''</em><span class="sig-paren">)</span><a class="headerlink" href="#koalanlp.proc.EntityRecognizer" title="정의 주소">¶</a></dt>
<dd><p>기반 클래스: <code class="xref py py-class docutils literal notranslate"><span class="pre">koalanlp.proc.__CanAnalyzeProperty</span></code></p>
<p>개체명 인식기를 초기화합니다.</p>
<dl class="field-list simple">
<dt class="field-odd">매개변수</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>api</strong> (<em>str</em>) -- 사용할 분석기의 유형.</p></li>
<li><p><strong>apiKey</strong> (<em>str</em>) -- ETRI 분석기의 경우, ETRI에서 발급받은 API Key</p></li>
</ul>
</dd>
</dl>
<dl class="method">
<dt id="koalanlp.proc.EntityRecognizer.analyze">
<code class="sig-name descname">analyze</code><span class="sig-paren">(</span><em class="sig-param">*text</em><span class="sig-paren">)</span> &#x2192; List[koalanlp.data.Sentence]<a class="headerlink" href="#koalanlp.proc.EntityRecognizer.analyze" title="정의 주소">¶</a></dt>
<dd><p>문단(들)을 분석합니다.</p>
<dl class="field-list simple">
<dt class="field-odd">매개변수</dt>
<dd class="field-odd"><p><strong>text</strong> (<em>Union</em><em>[</em><em>str</em><em>,</em><a class="reference internal" href="#koalanlp.data.Sentence" title="koalanlp.data.Sentence"><em>Sentence</em></a><em>,</em><em>List</em><em>[</em><em>str</em><em>]</em><em>,</em><em>List</em><em>[</em><a class="reference internal" href="#koalanlp.data.Sentence" title="koalanlp.data.Sentence"><em>Sentence</em></a><em>]</em><em>]</em>) -- 분석할 문단(들).
각 인자는 텍스트(str), 문장 객체(Sentence), 텍스트의 리스트, 문장 객체의 리스트 혼용 가능 (가변인자)</p>
</dd>
<dt class="field-even">반환 형식</dt>
<dd class="field-even"><p>List[<a class="reference internal" href="#koalanlp.data.Sentence" title="koalanlp.data.Sentence">Sentence</a>]</p>
</dd>
<dt class="field-odd">반환값</dt>
<dd class="field-odd"><p>분석된 결과들. (flattened list)</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="koalanlp.proc.RoleLabeler">
<em class="property">class </em><code class="sig-prename descclassname">koalanlp.proc.</code><code class="sig-name descname">RoleLabeler</code><span class="sig-paren">(</span><em class="sig-param">api: str</em>, <em class="sig-param">apiKey: str = ''</em><span class="sig-paren">)</span><a class="headerlink" href="#koalanlp.proc.RoleLabeler" title="정의 주소">¶</a></dt>
<dd><p>기반 클래스: <code class="xref py py-class docutils literal notranslate"><span class="pre">koalanlp.proc.__CanAnalyzeProperty</span></code></p>
<p>의미역 분석기를 초기화합니다.</p>
<dl class="field-list simple">
<dt class="field-odd">매개변수</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>api</strong> (<em>str</em>) -- 사용할 분석기의 유형.</p></li>
<li><p><strong>apiKey</strong> (<em>str</em>) -- ETRI 분석기의 경우, ETRI에서 발급받은 API Key</p></li>
</ul>
</dd>
</dl>
<dl class="method">
<dt id="koalanlp.proc.RoleLabeler.analyze">
<code class="sig-name descname">analyze</code><span class="sig-paren">(</span><em class="sig-param">*text</em><span class="sig-paren">)</span> &#x2192; List[koalanlp.data.Sentence]<a class="headerlink" href="#koalanlp.proc.RoleLabeler.analyze" title="정의 주소">¶</a></dt>
<dd><p>문단(들)을 분석합니다.</p>
<dl class="field-list simple">
<dt class="field-odd">매개변수</dt>
<dd class="field-odd"><p><strong>text</strong> (<em>Union</em><em>[</em><em>str</em><em>,</em><a class="reference internal" href="#koalanlp.data.Sentence" title="koalanlp.data.Sentence"><em>Sentence</em></a><em>,</em><em>List</em><em>[</em><em>str</em><em>]</em><em>,</em><em>List</em><em>[</em><a class="reference internal" href="#koalanlp.data.Sentence" title="koalanlp.data.Sentence"><em>Sentence</em></a><em>]</em><em>]</em>) -- 분석할 문단(들).
각 인자는 텍스트(str), 문장 객체(Sentence), 텍스트의 리스트, 문장 객체의 리스트 혼용 가능 (가변인자)</p>
</dd>
<dt class="field-even">반환 형식</dt>
<dd class="field-even"><p>List[<a class="reference internal" href="#koalanlp.data.Sentence" title="koalanlp.data.Sentence">Sentence</a>]</p>
</dd>
<dt class="field-odd">반환값</dt>
<dd class="field-odd"><p>분석된 결과들. (flattened list)</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="koalanlp.proc.Dictionary">
<em class="property">class </em><code class="sig-prename descclassname">koalanlp.proc.</code><code class="sig-name descname">Dictionary</code><span class="sig-paren">(</span><em class="sig-param">api: &lt;module 'koalanlp.API' from '/home/bydelta/PycharmProjects/python-support/koalanlp/API.py'&gt;</em><span class="sig-paren">)</span><a class="headerlink" href="#koalanlp.proc.Dictionary" title="정의 주소">¶</a></dt>
<dd><p>기반 클래스: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>사용자 정의 사전을 연결합니다.</p>
<dl class="field-list simple">
<dt class="field-odd">매개변수</dt>
<dd class="field-odd"><p><strong>api</strong> (<em>str</em>) -- 사용자 정의 사전을 연결할 API 패키지.</p>
</dd>
</dl>
<dl class="method">
<dt id="koalanlp.proc.Dictionary.addUserDictionary">
<code class="sig-name descname">addUserDictionary</code><span class="sig-paren">(</span><em class="sig-param">*pairs</em><span class="sig-paren">)</span><a class="headerlink" href="#koalanlp.proc.Dictionary.addUserDictionary" title="정의 주소">¶</a></dt>
<dd><p>사용자 사전에, 표면형과 그 품사를 추가.</p>
<dl class="field-list simple">
<dt class="field-odd">매개변수</dt>
<dd class="field-odd"><p><strong>pairs</strong> (<em>Tuple</em><em>[</em><em>str</em><em>,</em><a class="reference internal" href="#koalanlp.types.POS" title="koalanlp.types.POS"><em>POS</em></a><em>]</em>) -- (표면형, 품사)의 가변형 인자</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="koalanlp.proc.Dictionary.contains">
<code class="sig-name descname">contains</code><span class="sig-paren">(</span><em class="sig-param">word: str</em>, <em class="sig-param">*pos_tags</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#koalanlp.proc.Dictionary.contains" title="정의 주소">¶</a></dt>
<dd><p>사전에 등재되어 있는지 확인합니다.</p>
<dl class="field-list simple">
<dt class="field-odd">매개변수</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>word</strong> (<em>str</em>) -- 확인할 형태소</p></li>
<li><p><strong>pos_tags</strong> (<a class="reference internal" href="#koalanlp.types.POS" title="koalanlp.types.POS"><em>POS</em></a>) -- 세종품사들(기본값: NNP 고유명사, NNG 일반명사)</p></li>
</ul>
</dd>
<dt class="field-even">반환 형식</dt>
<dd class="field-even"><p>bool</p>
</dd>
<dt class="field-odd">반환값</dt>
<dd class="field-odd"><p>사전에 포함된다면 True 아니면 False.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="koalanlp.proc.Dictionary.getBaseEntries">
<code class="sig-name descname">getBaseEntries</code><span class="sig-paren">(</span><em class="sig-param">filter=&lt;function Dictionary.&lt;lambda&gt;&gt;</em><span class="sig-paren">)</span><a class="headerlink" href="#koalanlp.proc.Dictionary.getBaseEntries" title="정의 주소">¶</a></dt>
<dd><p>원본 사전에 등재된 항목 중에서, 지정된 형태소의 항목만을 가져옵니다. (복합 품사 결합 형태는 제외)</p>
<dl class="field-list simple">
<dt class="field-odd">매개변수</dt>
<dd class="field-odd"><p><strong>filter</strong> (<em>Union</em><em>[</em><em>Set</em><em>[</em><a class="reference internal" href="#koalanlp.types.POS" title="koalanlp.types.POS"><em>POS</em></a><em>]</em><em>,</em><em>POS-&gt;bool</em><em>]</em>) -- 가져올 품사나, 품사의 리스트, 또는 해당 품사인지 판단하는 함수.</p>
</dd>
<dt class="field-even">반환 형식</dt>
<dd class="field-even"><p>generator</p>
</dd>
<dt class="field-odd">반환값</dt>
<dd class="field-odd"><p>(형태소, 품사)의 generator</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="koalanlp.proc.Dictionary.getItems">
<code class="sig-name descname">getItems</code><span class="sig-paren">(</span><span class="sig-paren">)</span> &#x2192; List[Tuple[str, koalanlp.types.POS]]<a class="headerlink" href="#koalanlp.proc.Dictionary.getItems" title="정의 주소">¶</a></dt>
<dd><p>사용자 사전에 등재된 모든 항목을 가져옵니다.</p>
<dl class="field-list simple">
<dt class="field-odd">반환 형식</dt>
<dd class="field-odd"><p>List[(str,<a class="reference internal" href="#koalanlp.types.POS" title="koalanlp.types.POS">POS</a>)]</p>
</dd>
<dt class="field-even">반환값</dt>
<dd class="field-even"><p>(형태소, 품사)의 set</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="koalanlp.proc.Dictionary.getNotExists">
<code class="sig-name descname">getNotExists</code><span class="sig-paren">(</span><em class="sig-param">onlySystemDic: bool</em>, <em class="sig-param">*word</em><span class="sig-paren">)</span> &#x2192; List[Tuple[str, koalanlp.types.POS]]<a class="headerlink" href="#koalanlp.proc.Dictionary.getNotExists" title="정의 주소">¶</a></dt>
<dd><p>사전에 등재되어 있는지 확인하고, 사전에 없는단어만 반환합니다.</p>
<dl class="field-list simple">
<dt class="field-odd">매개변수</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>onlySystemDic</strong> (<em>bool</em>) -- 시스템 사전에서만 검색할지 결정합니다.</p></li>
<li><p><strong>word</strong> (<em>Tuple</em><em>[</em><em>str</em><em>,</em><a class="reference internal" href="#koalanlp.types.POS" title="koalanlp.types.POS"><em>POS</em></a><em>]</em>) -- 확인할 (형태소, 품사)들의 가변인자</p></li>
</ul>
</dd>
<dt class="field-even">반환 형식</dt>
<dd class="field-even"><p>List[(str,<a class="reference internal" href="#koalanlp.types.POS" title="koalanlp.types.POS">POS</a>)]</p>
</dd>
<dt class="field-odd">반환값</dt>
<dd class="field-odd"><p>사전에 없는 단어들.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="koalanlp.proc.Dictionary.importFrom">
<code class="sig-name descname">importFrom</code><span class="sig-paren">(</span><em class="sig-param">other</em>, <em class="sig-param">fastAppend=False</em>, <em class="sig-param">filter=&lt;function Dictionary.&lt;lambda&gt;&gt;</em><span class="sig-paren">)</span><a class="headerlink" href="#koalanlp.proc.Dictionary.importFrom" title="정의 주소">¶</a></dt>
<dd><p>다른 사전을 참조하여, 선택된 사전에 없는 단어를 사용자사전으로 추가합니다.</p>
<dl class="field-list simple">
<dt class="field-odd">매개변수</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>other</strong> (<a class="reference internal" href="#koalanlp.proc.Dictionary" title="koalanlp.proc.Dictionary"><em>Dictionary</em></a>) -- 참조할 사전</p></li>
<li><p><strong>fastAppend</strong> (<em>bool</em>) -- 선택된 사전에 존재하는지를 검사하지 않고 빠르게 추가하고자 할 때. (기본값 False)</p></li>
<li><p><strong>filter</strong> (<em>Union</em><em>[</em><em>Set</em><em>[</em><a class="reference internal" href="#koalanlp.types.POS" title="koalanlp.types.POS"><em>POS</em></a><em>]</em><em>,</em><em>POS-&gt;bool</em><em>]</em>) -- 가져올 품사나, 품사의 리스트, 또는 해당 품사인지 판단하는 함수.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-koalanlp.ExtUtil">
<span id="id4"></span><h2>문자열 추가기능<a class="headerlink" href="#module-koalanlp.ExtUtil" title="제목 주소">¶</a></h2>
<dl class="data">
<dt id="koalanlp.ExtUtil.ChoToJong">
<code class="sig-prename descclassname">koalanlp.ExtUtil.</code><code class="sig-name descname">ChoToJong</code><em class="property"> = {'ᄀ': 'ᆨ', 'ᄁ': 'ᆩ', 'ᄂ': 'ᆫ', 'ᄃ': 'ᆮ', 'ᄅ': 'ᆯ', 'ᄆ': 'ᆷ', 'ᄇ': 'ᆸ', 'ᄉ': 'ᆺ', 'ᄊ': 'ᆻ', 'ᄋ': 'ᆼ', 'ᄌ': 'ᆽ', 'ᄎ': 'ᆾ', 'ᄏ': 'ᆿ', 'ᄐ': 'ᇀ', 'ᄑ': 'ᇁ', 'ᄒ': 'ᇂ', 'ㄱ': 'ᆨ', 'ㄲ': 'ᆩ', 'ㄳ': 'ᆪ', 'ㄴ': 'ᆫ', 'ㄵ': 'ᆬ', 'ㄶ': 'ᆭ', 'ㄷ': 'ᆮ', 'ㄹ': 'ᆯ', 'ㄺ': 'ᆰ', 'ㄻ': 'ᆱ', 'ㄼ': 'ᆲ', 'ㄽ': 'ᆳ', 'ㄾ': 'ᆴ', 'ㄿ': 'ᆵ', 'ㅀ': 'ᆶ', 'ㅁ': 'ᆷ', 'ㅂ': 'ᆸ', 'ㅄ': 'ᆹ', 'ㅅ': 'ᆺ', 'ㅆ': 'ᆻ', 'ㅇ': 'ᆼ', 'ㅈ': 'ᆽ', 'ㅊ': 'ᆾ', 'ㅋ': 'ᆿ', 'ㅌ': 'ᇀ', 'ㅍ': 'ᇁ', 'ㅎ': 'ᇂ'}</em><a class="headerlink" href="#koalanlp.ExtUtil.ChoToJong" title="정의 주소">¶</a></dt>
<dd><p>초성 문자를 종성 조합형 문자로 변경</p>
</dd></dl>

<dl class="data">
<dt id="koalanlp.ExtUtil.HanFirstList">
<code class="sig-prename descclassname">koalanlp.ExtUtil.</code><code class="sig-name descname">HanFirstList</code><em class="property"> = ['ᄀ', 'ᄁ', 'ᄂ', 'ᄃ', 'ᄄ', 'ᄅ', 'ᄆ', 'ᄇ', 'ᄈ', 'ᄉ', 'ᄊ', 'ᄋ', 'ᄌ', 'ᄍ', 'ᄎ', 'ᄏ', 'ᄐ', 'ᄑ', 'ᄒ']</em><a class="headerlink" href="#koalanlp.ExtUtil.HanFirstList" title="정의 주소">¶</a></dt>
<dd><p>초성 조합형 문자열 리스트 (UNICODE 순서)</p>
</dd></dl>

<dl class="data">
<dt id="koalanlp.ExtUtil.HanSecondList">
<code class="sig-prename descclassname">koalanlp.ExtUtil.</code><code class="sig-name descname">HanSecondList</code><em class="property"> = ['ᅡ', 'ᅢ', 'ᅣ', 'ᅤ', 'ᅥ', 'ᅦ', 'ᅧ', 'ᅨ', 'ᅩ', 'ᅪ', 'ᅫ', 'ᅬ', 'ᅭ', 'ᅮ', 'ᅯ', 'ᅰ', 'ᅱ', 'ᅲ', 'ᅳ', 'ᅴ', 'ᅵ']</em><a class="headerlink" href="#koalanlp.ExtUtil.HanSecondList" title="정의 주소">¶</a></dt>
<dd><p>중성 조합형 문자열 리스트 (UNICODE 순서)</p>
</dd></dl>

<dl class="data">
<dt id="koalanlp.ExtUtil.HanLastList">
<code class="sig-prename descclassname">koalanlp.ExtUtil.</code><code class="sig-name descname">HanLastList</code><em class="property"> = [None, 'ᆨ', 'ᆩ', 'ᆪ', 'ᆫ', 'ᆬ', 'ᆭ', 'ᆮ', 'ᆯ', 'ᆰ', 'ᆱ', 'ᆲ', 'ᆳ', 'ᆴ', 'ᆵ', 'ᆶ', 'ᆷ', 'ᆸ', 'ᆹ', 'ᆺ', 'ᆻ', 'ᆼ', 'ᆽ', 'ᆾ', 'ᆿ', 'ᇀ', 'ᇁ', 'ᇂ']</em><a class="headerlink" href="#koalanlp.ExtUtil.HanLastList" title="정의 주소">¶</a></dt>
<dd><p>종성 조합형 문자열 리스트 (UNICODE 순서). 가장 첫번째는 null (받침 없음)</p>
</dd></dl>

<dl class="function">
<dt id="koalanlp.ExtUtil.alphaToHangul">
<code class="sig-prename descclassname">koalanlp.ExtUtil.</code><code class="sig-name descname">alphaToHangul</code><span class="sig-paren">(</span><em class="sig-param">text: str</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#koalanlp.ExtUtil.alphaToHangul" title="정의 주소">¶</a></dt>
<dd><p>주어진 문자열에서 알파벳이 발음되는 대로 국문 문자열로 표기하여 값으로 돌려줍니다.</p>
<dl class="field-list simple">
<dt class="field-odd">매개변수</dt>
<dd class="field-odd"><p><strong>text</strong> (<em>str</em>) -- 알파벳을 발음할 문자열</p>
</dd>
<dt class="field-even">반환 형식</dt>
<dd class="field-even"><p>str</p>
</dd>
<dt class="field-odd">반환값</dt>
<dd class="field-odd"><p>국문 발음 표기된 문자열</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="koalanlp.ExtUtil.hangulToAlpha">
<code class="sig-prename descclassname">koalanlp.ExtUtil.</code><code class="sig-name descname">hangulToAlpha</code><span class="sig-paren">(</span><em class="sig-param">text: str</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#koalanlp.ExtUtil.hangulToAlpha" title="정의 주소">¶</a></dt>
<dd><p>주어진 문자열에 적힌 알파벳 발음을 알파벳으로 변환하여 문자열로 반환합니다.</p>
<dl class="field-list simple">
<dt class="field-odd">매개변수</dt>
<dd class="field-odd"><p><strong>text</strong> (<em>str</em>) -- 국문 발음 표기된 문자열</p>
</dd>
<dt class="field-even">반환 형식</dt>
<dd class="field-even"><p>str</p>
</dd>
<dt class="field-odd">반환값</dt>
<dd class="field-odd"><p>영문 변환된 문자열</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="koalanlp.ExtUtil.isAlphaPronounced">
<code class="sig-prename descclassname">koalanlp.ExtUtil.</code><code class="sig-name descname">isAlphaPronounced</code><span class="sig-paren">(</span><em class="sig-param">text: str</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#koalanlp.ExtUtil.isAlphaPronounced" title="정의 주소">¶</a></dt>
<dd><p>주어진 문자열이 알파벳이 발음되는 대로 표기된 문자열인지 확인합니다.</p>
<dl class="field-list simple">
<dt class="field-odd">매개변수</dt>
<dd class="field-odd"><p><strong>text</strong> (<em>str</em>) -- 확인할 문자열</p>
</dd>
<dt class="field-even">반환 형식</dt>
<dd class="field-even"><p>bool</p>
</dd>
<dt class="field-odd">반환값</dt>
<dd class="field-odd"><p>영문 발음으로만 구성되었다면 true</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="koalanlp.ExtUtil.isHanja">
<code class="sig-prename descclassname">koalanlp.ExtUtil.</code><code class="sig-name descname">isHanja</code><span class="sig-paren">(</span><em class="sig-param">text: str</em><span class="sig-paren">)</span> &#x2192; List[bool]<a class="headerlink" href="#koalanlp.ExtUtil.isHanja" title="정의 주소">¶</a></dt>
<dd><p>문자열의 각 문자가 한자 범위인지 확인합니다.</p>
<dl class="field-list simple">
<dt class="field-odd">매개변수</dt>
<dd class="field-odd"><p><strong>text</strong> (<em>str</em>) -- 확인할 문자열</p>
</dd>
<dt class="field-even">반환 형식</dt>
<dd class="field-even"><p>List[bool]</p>
</dd>
<dt class="field-odd">반환값</dt>
<dd class="field-odd"><p>문자열 문자의 위치마다 한자인지 아닌지를 표기한 리스트. 한자라면 True.</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="koalanlp.ExtUtil.isCJKHanja">
<code class="sig-prename descclassname">koalanlp.ExtUtil.</code><code class="sig-name descname">isCJKHanja</code><span class="sig-paren">(</span><em class="sig-param">text: str</em><span class="sig-paren">)</span> &#x2192; List[bool]<a class="headerlink" href="#koalanlp.ExtUtil.isCJKHanja" title="정의 주소">¶</a></dt>
<dd><p>현재 문자가 한중일 통합한자, 통합한자 확장 - A, 호환용 한자 범위인지 확인합니다.
(국사편찬위원회 한자음가사전은 해당 범위에서만 정의되어 있어, 별도 확인합니다.)</p>
<dl class="field-list simple">
<dt class="field-odd">매개변수</dt>
<dd class="field-odd"><p><strong>text</strong> (<em>str</em>) -- 확인할 문자열</p>
</dd>
<dt class="field-even">반환 형식</dt>
<dd class="field-even"><p>List[bool]</p>
</dd>
<dt class="field-odd">반환값</dt>
<dd class="field-odd"><p>문자열 문자의 위치마다 한자인지 아닌지를 표기한 리스트. 한자라면 True.</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="koalanlp.ExtUtil.hanjaToHangul">
<code class="sig-prename descclassname">koalanlp.ExtUtil.</code><code class="sig-name descname">hanjaToHangul</code><span class="sig-paren">(</span><em class="sig-param">text: str</em>, <em class="sig-param">headCorrection: bool = True</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#koalanlp.ExtUtil.hanjaToHangul" title="정의 주소">¶</a></dt>
<dd><p>국사편찬위원회 한자음가사전에 따라 한자 표기된 내용을 국문 표기로 전환합니다.</p>
<p>참고:</p>
<blockquote>
<div><ul class="simple">
<li><p>[headCorrection] 값이 true인 경우, whitespace에 따라오는 문자에 두음법칙을 자동 적용함. (기본값 true)</p></li>
<li><p>단, 다음 의존명사는 예외: 냥(兩), 년(年), 리(里), 리(理), 량(輛)</p></li>
<li><dl class="simple">
<dt>다음 두음법칙은 사전을 조회하지 않기 때문에 적용되지 않음에 유의</dt><dd><ul>
<li><p>한자 파생어나 합성어에서 원 단어의 두음법칙: 예) &quot;신여성&quot;이 옳은 표기이나 &quot;신녀성&quot;으로 표기됨</p></li>
<li><p>외자가 아닌 이름: 예) &quot;허난설헌&quot;이 옳은 표기이나 &quot;허란설헌&quot;으로 표기됨</p></li>
</ul>
</dd>
</dl>
</li>
</ul>
</div></blockquote>
<dl class="field-list simple">
<dt class="field-odd">매개변수</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>text</strong> -- 국문 표기로 전환할 문자열</p></li>
<li><p><strong>headCorrection</strong> -- 두음법칙 적용 여부 (기본값 True)</p></li>
</ul>
</dd>
<dt class="field-even">반환값</dt>
<dd class="field-even"><p>국문 표기로 전환된 문자열</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="koalanlp.ExtUtil.isCompleteHangul">
<code class="sig-prename descclassname">koalanlp.ExtUtil.</code><code class="sig-name descname">isCompleteHangul</code><span class="sig-paren">(</span><em class="sig-param">text: str</em><span class="sig-paren">)</span> &#x2192; List[bool]<a class="headerlink" href="#koalanlp.ExtUtil.isCompleteHangul" title="정의 주소">¶</a></dt>
<dd><p>현재 문자가 초성, 중성, 종성(선택적)을 다 갖춘 문자인지 확인합니다.</p>
<dl class="field-list simple">
<dt class="field-odd">매개변수</dt>
<dd class="field-odd"><p><strong>text</strong> (<em>str</em>) -- 확인할 문자열</p>
</dd>
<dt class="field-even">반환 형식</dt>
<dd class="field-even"><p>List[bool]</p>
</dd>
<dt class="field-odd">반환값</dt>
<dd class="field-odd"><p>문자열 문자의 위치마다 확인여부를 표기한 리스트. 맞다면 True.</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="koalanlp.ExtUtil.isIncompleteHangul">
<code class="sig-prename descclassname">koalanlp.ExtUtil.</code><code class="sig-name descname">isIncompleteHangul</code><span class="sig-paren">(</span><em class="sig-param">text: str</em><span class="sig-paren">)</span> &#x2192; List[bool]<a class="headerlink" href="#koalanlp.ExtUtil.isIncompleteHangul" title="정의 주소">¶</a></dt>
<dd><p>현재 문자가 불완전한 한글 문자인지 확인합니다.</p>
<dl class="field-list simple">
<dt class="field-odd">매개변수</dt>
<dd class="field-odd"><p><strong>text</strong> (<em>str</em>) -- 확인할 문자열</p>
</dd>
<dt class="field-even">반환 형식</dt>
<dd class="field-even"><p>List[bool]</p>
</dd>
<dt class="field-odd">반환값</dt>
<dd class="field-odd"><p>문자열 문자의 위치마다 확인여부를 표기한 리스트. 맞다면 True.</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="koalanlp.ExtUtil.isHangul">
<code class="sig-prename descclassname">koalanlp.ExtUtil.</code><code class="sig-name descname">isHangul</code><span class="sig-paren">(</span><em class="sig-param">text: str</em><span class="sig-paren">)</span> &#x2192; List[bool]<a class="headerlink" href="#koalanlp.ExtUtil.isHangul" title="정의 주소">¶</a></dt>
<dd><p>현재 문자가 한글 완성형 또는 조합용 문자인지 확인합니다.</p>
<dl class="field-list simple">
<dt class="field-odd">매개변수</dt>
<dd class="field-odd"><p><strong>text</strong> (<em>str</em>) -- 확인할 문자열</p>
</dd>
<dt class="field-even">반환 형식</dt>
<dd class="field-even"><p>List[bool]</p>
</dd>
<dt class="field-odd">반환값</dt>
<dd class="field-odd"><p>문자열 문자의 위치마다 확인여부를 표기한 리스트. 맞다면 True.</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="koalanlp.ExtUtil.isHangulEnding">
<code class="sig-prename descclassname">koalanlp.ExtUtil.</code><code class="sig-name descname">isHangulEnding</code><span class="sig-paren">(</span><em class="sig-param">text: str</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#koalanlp.ExtUtil.isHangulEnding" title="정의 주소">¶</a></dt>
<dd><p>현재 문자열이 한글 (완성/조합)로 끝나는지 확인합니다.</p>
<dl class="field-list simple">
<dt class="field-odd">매개변수</dt>
<dd class="field-odd"><p><strong>text</strong> (<em>str</em>) -- 확인할 문자열</p>
</dd>
<dt class="field-even">반환 형식</dt>
<dd class="field-even"><p>bool</p>
</dd>
<dt class="field-odd">반환값</dt>
<dd class="field-odd"><p>맞다면 True.</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="koalanlp.ExtUtil.isChosungJamo">
<code class="sig-prename descclassname">koalanlp.ExtUtil.</code><code class="sig-name descname">isChosungJamo</code><span class="sig-paren">(</span><em class="sig-param">text: str</em><span class="sig-paren">)</span> &#x2192; List[bool]<a class="headerlink" href="#koalanlp.ExtUtil.isChosungJamo" title="정의 주소">¶</a></dt>
<dd><p>현재 문자가 현대 한글 초성 자음 문자인지 확인합니다.</p>
<dl class="field-list simple">
<dt class="field-odd">매개변수</dt>
<dd class="field-odd"><p><strong>text</strong> (<em>str</em>) -- 확인할 문자열</p>
</dd>
<dt class="field-even">반환 형식</dt>
<dd class="field-even"><p>List[bool]</p>
</dd>
<dt class="field-odd">반환값</dt>
<dd class="field-odd"><p>문자열 문자의 위치마다 확인여부를 표기한 리스트. 맞다면 True.</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="koalanlp.ExtUtil.isJungsungJamo">
<code class="sig-prename descclassname">koalanlp.ExtUtil.</code><code class="sig-name descname">isJungsungJamo</code><span class="sig-paren">(</span><em class="sig-param">text: str</em><span class="sig-paren">)</span> &#x2192; List[bool]<a class="headerlink" href="#koalanlp.ExtUtil.isJungsungJamo" title="정의 주소">¶</a></dt>
<dd><p>현재 문자가 현대 한글 중성 모음 문자인지 확인합니다.</p>
<dl class="field-list simple">
<dt class="field-odd">매개변수</dt>
<dd class="field-odd"><p><strong>text</strong> (<em>str</em>) -- 확인할 문자열</p>
</dd>
<dt class="field-even">반환 형식</dt>
<dd class="field-even"><p>List[bool]</p>
</dd>
<dt class="field-odd">반환값</dt>
<dd class="field-odd"><p>문자열 문자의 위치마다 확인여부를 표기한 리스트. 맞다면 True.</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="koalanlp.ExtUtil.isJongsungJamo">
<code class="sig-prename descclassname">koalanlp.ExtUtil.</code><code class="sig-name descname">isJongsungJamo</code><span class="sig-paren">(</span><em class="sig-param">text: str</em><span class="sig-paren">)</span> &#x2192; List[bool]<a class="headerlink" href="#koalanlp.ExtUtil.isJongsungJamo" title="정의 주소">¶</a></dt>
<dd><p>현재 문자가 현대 한글 종성 자음 문자인지 확인합니다.</p>
<dl class="field-list simple">
<dt class="field-odd">매개변수</dt>
<dd class="field-odd"><p><strong>text</strong> (<em>str</em>) -- 확인할 문자열</p>
</dd>
<dt class="field-even">반환 형식</dt>
<dd class="field-even"><p>List[bool]</p>
</dd>
<dt class="field-odd">반환값</dt>
<dd class="field-odd"><p>문자열 문자의 위치마다 확인여부를 표기한 리스트. 맞다면 True.</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="koalanlp.ExtUtil.isJongsungEnding">
<code class="sig-prename descclassname">koalanlp.ExtUtil.</code><code class="sig-name descname">isJongsungEnding</code><span class="sig-paren">(</span><em class="sig-param">text: str</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#koalanlp.ExtUtil.isJongsungEnding" title="정의 주소">¶</a></dt>
<dd><p>현재 문자열이 종성으로 끝인지 확인합니다.</p>
<dl class="field-list simple">
<dt class="field-odd">매개변수</dt>
<dd class="field-odd"><p><strong>text</strong> (<em>str</em>) -- 확인할 문자열</p>
</dd>
<dt class="field-even">반환 형식</dt>
<dd class="field-even"><p>bool</p>
</dd>
<dt class="field-odd">반환값</dt>
<dd class="field-odd"><p>맞다면 True.</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="koalanlp.ExtUtil.getChosung">
<code class="sig-prename descclassname">koalanlp.ExtUtil.</code><code class="sig-name descname">getChosung</code><span class="sig-paren">(</span><em class="sig-param">text: str</em><span class="sig-paren">)</span> &#x2192; List[Union[None, str]]<a class="headerlink" href="#koalanlp.ExtUtil.getChosung" title="정의 주소">¶</a></dt>
<dd><p>현재 문자에서 초성 자음문자를 분리합니다. 초성이 없으면 None.</p>
<dl class="field-list simple">
<dt class="field-odd">매개변수</dt>
<dd class="field-odd"><p><strong>text</strong> (<em>str</em>) -- 분리할 문자열</p>
</dd>
<dt class="field-even">반환 형식</dt>
<dd class="field-even"><p>List[Union[None,str]]</p>
</dd>
<dt class="field-odd">반환값</dt>
<dd class="field-odd"><p>분리된 각 초성이 들어간 리스트.</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="koalanlp.ExtUtil.getJungsung">
<code class="sig-prename descclassname">koalanlp.ExtUtil.</code><code class="sig-name descname">getJungsung</code><span class="sig-paren">(</span><em class="sig-param">text: str</em><span class="sig-paren">)</span> &#x2192; List[Union[None, str]]<a class="headerlink" href="#koalanlp.ExtUtil.getJungsung" title="정의 주소">¶</a></dt>
<dd><p>현재 문자에서 중성 모음문자를 분리합니다. 중성이 없으면 None.</p>
<dl class="field-list simple">
<dt class="field-odd">매개변수</dt>
<dd class="field-odd"><p><strong>text</strong> (<em>str</em>) -- 분리할 문자열</p>
</dd>
<dt class="field-even">반환 형식</dt>
<dd class="field-even"><p>List[Union[None,str]]</p>
</dd>
<dt class="field-odd">반환값</dt>
<dd class="field-odd"><p>분리된 각 중성이 들어간 리스트.</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="koalanlp.ExtUtil.getJongsung">
<code class="sig-prename descclassname">koalanlp.ExtUtil.</code><code class="sig-name descname">getJongsung</code><span class="sig-paren">(</span><em class="sig-param">text: str</em><span class="sig-paren">)</span> &#x2192; List[Union[None, str]]<a class="headerlink" href="#koalanlp.ExtUtil.getJongsung" title="정의 주소">¶</a></dt>
<dd><p>현재 문자에서 종성 자음문자를 분리합니다. 종성이 없으면 None.</p>
<dl class="field-list simple">
<dt class="field-odd">매개변수</dt>
<dd class="field-odd"><p><strong>text</strong> (<em>str</em>) -- 분리할 문자열</p>
</dd>
<dt class="field-even">반환 형식</dt>
<dd class="field-even"><p>List[Union[None,str]]</p>
</dd>
<dt class="field-odd">반환값</dt>
<dd class="field-odd"><p>분리된 각 종성이 들어간 리스트.</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="koalanlp.ExtUtil.dissembleHangul">
<code class="sig-prename descclassname">koalanlp.ExtUtil.</code><code class="sig-name descname">dissembleHangul</code><span class="sig-paren">(</span><em class="sig-param">text: str</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#koalanlp.ExtUtil.dissembleHangul" title="정의 주소">¶</a></dt>
<dd><p>현재 문자열을 초성, 중성, 종성 자음문자로 분리하여 새 문자열을 만듭니다. 종성이 없으면 종성은 쓰지 않습니다.</p>
<dl class="field-list simple">
<dt class="field-odd">매개변수</dt>
<dd class="field-odd"><p><strong>text</strong> (<em>str</em>) -- 분해할 문자열</p>
</dd>
<dt class="field-even">반환 형식</dt>
<dd class="field-even"><p>str</p>
</dd>
<dt class="field-odd">반환값</dt>
<dd class="field-odd"><p>분해된 문자열</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="koalanlp.ExtUtil.assembleHangul">
<code class="sig-prename descclassname">koalanlp.ExtUtil.</code><code class="sig-name descname">assembleHangul</code><span class="sig-paren">(</span><em class="sig-param">text: str</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#koalanlp.ExtUtil.assembleHangul" title="정의 주소">¶</a></dt>
<dd><p>주어진 문자열에서 초성, 중성, 종성이 연달아 나오는 경우 이를 조합하여 한글 문자를 재구성합니다.</p>
<dl class="field-list simple">
<dt class="field-odd">매개변수</dt>
<dd class="field-odd"><p><strong>text</strong> (<em>str</em>) -- 조합할 문자열</p>
</dd>
<dt class="field-even">반환 형식</dt>
<dd class="field-even"><p>str</p>
</dd>
<dt class="field-odd">반환값</dt>
<dd class="field-odd"><p>조합형 문자들이 조합된 문자열. 조합이 불가능한 문자는 그대로 남습니다.</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="koalanlp.ExtUtil.correctVerbApply">
<code class="sig-prename descclassname">koalanlp.ExtUtil.</code><code class="sig-name descname">correctVerbApply</code><span class="sig-paren">(</span><em class="sig-param">verb: str</em>, <em class="sig-param">isVerb: bool</em>, <em class="sig-param">rest: str</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#koalanlp.ExtUtil.correctVerbApply" title="정의 주소">¶</a></dt>
<dd><p>주어진 용언의 원형 [verb]이 뒷 부분 [rest]와 같이 어미가 붙어 활용될 때, 불규칙 활용 용언과 모음조화를 교정합니다.</p>
<dl class="field-list simple">
<dt class="field-odd">매개변수</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>verb</strong> (<em>str</em>) -- 용언 원형인 어근을 표현한 String. '-다.' 와 같은 어미는 없는 어근 상태입니다.</p></li>
<li><p><strong>isVerb</strong> (<em>bool</em>) -- 동사인지 형용사인지 나타내는 지시자. 동사이면 true.</p></li>
<li><p><strong>rest</strong> (<em>str</em>) -- 어근에 붙일 어미를 표현한 String.</p></li>
</ul>
</dd>
<dt class="field-even">반환 형식</dt>
<dd class="field-even"><p>str</p>
</dd>
<dt class="field-odd">반환값</dt>
<dd class="field-odd"><p>모음조화나 불규칙 활용이 교정된 원형+어미 결합</p>
</dd>
</dl>
</dd></dl>

</div>
<div class="section" id="module-koalanlp.Util">
<span id="id5"></span><h2>편의기능<a class="headerlink" href="#module-koalanlp.Util" title="제목 주소">¶</a></h2>
<dl class="function">
<dt id="koalanlp.Util.initialize">
<code class="sig-prename descclassname">koalanlp.Util.</code><code class="sig-name descname">initialize</code><span class="sig-paren">(</span><em class="sig-param">java_options='-Xmx4g -Dfile.encoding=utf-8'</em>, <em class="sig-param">**packages</em><span class="sig-paren">)</span><a class="headerlink" href="#koalanlp.Util.initialize" title="정의 주소">¶</a></dt>
<dd><p>초기화 함수. 필요한 Java library를 다운받습니다.
한번 초기화 된 다음에는 <a class="reference internal" href="#koalanlp.Util.finalize" title="koalanlp.Util.finalize"><code class="xref py py-func docutils literal notranslate"><span class="pre">koalanlp.Util.finalize()</span></code></a> 을 사용해 종료하지 않으면 다시 초기화 할 수 없습니다.</p>
<dl class="field-list simple">
<dt class="field-odd">매개변수</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>java_options</strong> (<em>str</em>) -- 자바 JVM option (기본값: &quot;-Xmx4g -Dfile.encoding=utf-8&quot;)</p></li>
<li><p><strong>packages</strong> (<em>Dict</em><em>[</em><em>str</em><em>,</em><em>str</em><em>]</em>) -- 사용할 분석기 API의 목록. (Keyword arguments; 기본값: KMR=&quot;LATEST&quot;)</p></li>
</ul>
</dd>
<dt class="field-even">예외</dt>
<dd class="field-even"><p><strong>Exception</strong> -- JVM이 2회 이상 초기화 될때 Exception.</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="koalanlp.Util.contains">
<code class="sig-prename descclassname">koalanlp.Util.</code><code class="sig-name descname">contains</code><span class="sig-paren">(</span><em class="sig-param">string_list: List[str], tag</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#koalanlp.Util.contains" title="정의 주소">¶</a></dt>
<dd><p>주어진 문자열 리스트에 구문분석 표지자/의존구문 표지자/의미역 표지/개체명 분류가 포함되는지 확인합니다.</p>
<dl class="field-list simple">
<dt class="field-odd">매개변수</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>string_list</strong> (<em>List</em><em>[</em><em>str</em><em>]</em>) -- 분류가 포함되는지 확인할 문자열 목록</p></li>
<li><p><strong>tag</strong> (<em>Union</em><em>[</em><a class="reference internal" href="#koalanlp.types.PhraseTag" title="koalanlp.types.PhraseTag"><em>PhraseTag</em></a><em>,</em><a class="reference internal" href="#koalanlp.types.DependencyTag" title="koalanlp.types.DependencyTag"><em>DependencyTag</em></a><em>,</em><a class="reference internal" href="#koalanlp.types.CoarseEntityType" title="koalanlp.types.CoarseEntityType"><em>CoarseEntityType</em></a><em>,</em><a class="reference internal" href="#koalanlp.types.RoleType" title="koalanlp.types.RoleType"><em>RoleType</em></a><em>]</em>) -- 포함되는지 확인할 구문분석 표지자/의존구문 표지자/의미역 표지/개체명 분류</p></li>
</ul>
</dd>
<dt class="field-even">반환 형식</dt>
<dd class="field-even"><p>bool</p>
</dd>
<dt class="field-odd">반환값</dt>
<dd class="field-odd"><p>포함되면 true</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="koalanlp.Util.finalize">
<code class="sig-prename descclassname">koalanlp.Util.</code><code class="sig-name descname">finalize</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#koalanlp.Util.finalize" title="정의 주소">¶</a></dt>
<dd><p>사용이 종료된 다음, 실행되어 있는 JVM을 종료합니다.</p>
</dd></dl>

</div>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
      
        <a href="index.html" class="btn btn-neutral float-left" title="KoalaNLP" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2018, KoalaNLP

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>